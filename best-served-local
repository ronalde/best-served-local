#!/usr/bin/env bash

## `best-served-local' is a bash script that helps serving (Google)
## web fonts from your own server, by creating valid css font-face
## atrules and/or downloading the font files.
##
##  Copyright Â© 2016 Ronald van Engelen <ronalde+github@lacocina.nl>
##  This program is free software: you can redistribute it and/or modify
##  it under the terms of the GNU General Public License as published by
##  the Free Software Foundation, either version 3 of the License, or
##  (at your option) any later version.
##
##  This program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##  GNU General Public License for more details.
##
##  You should have received a copy of the GNU General Public License
##  along with this program.  If not, see <http://www.gnu.org/licenses/>.
##
## The script, helpers and documentation are published at 
## https://lacocina.nl/using-best-served-local
##
## Inspired by https://github.com/neverpanic/google-font-download.git and
## https://github.com/neverpanic/google-font-download.git
## 
## Also see `README.md'

## constants and defaults
## font SUBSETSPECS to be downloaded, defaults to 'latin'
## see https://developers.google.com/fonts/docs/getting_started#specifying_script_subsets
DEF_ARG_SUBSETSPECS="latin"
## comma separated list of FORMATSPECS to be downloaded
## defaults to 'practical' (eg 'woff & woff2')
DEF_ARG_FORMATSPECS="practical"
## app defaults
APP_NAME="best-served-local"
APP_VERSION="0.8.3"
APP_URL="https://lacocina.nl/using-${APP_NAME}"
APP_GITHUBURL="https://github.com/ronalde/best-served-local"
## google constants
GOOGLE_FONTAPI_HOST="fonts.googleapis.com"
GOOGLE_FONTAPI_URL="https://${GOOGLE_FONTAPI_HOST}/css"
GOOGLE_FONTS_URL="https://fonts.google.com/"

cmd_download="${cmd_download:-}"

function err_exit() {
    ## display fatal error with error description $1 and exit with
    ## error $2 (default to 5)
    description="${1}"
    ## default to 5
    exit_code=${2:-5}
    ## 1: Invalid FONTSPEC
    ## 2: I/O error (handling directories and files)
    ## 3: Download error
    ## 4: Invalid argument (other than FONTSPECs)
    ## 5: None of the above
    printf 1>&2 "\nError: %s\n"  "${description}"
    printf 1>&2 "\nRun \`%s -h' to see usage information.\n" \
		"${APP_NAME}"
    exit "${exit_code}"
}

function get_download_cmd() {
    err_msg=
    case "${cmd_download}" in
	*curl)
	    cmd_curl=$(type -p curl)
	    if [[ $? -ne 0 ]]; then
		err_msg="- user specified download command (\`${cmd_download}') not found in path."
	    else
		cmd_download="${cmd_curl}"
	    fi
	    ;;
	*wget)
	    cmd_wget=$(type -p wget)
	    if [[ $? -ne 0 ]]; then
		err_msg="- user specified download command (\`${cmd_download}') not found in path."
	    else
		cmd_download="${cmd_wget}"
	    fi
	    ;;
	*)
	    ## not supplied as an environment variable
	    cmd_curl=$(type -p curl)
	    if [[ $? -ne 0 ]]; then
		## curl is not installed, try wget
		cmd_wget=$(type -p wget)
		if [[ $? -ne 0 ]]; then
		    err_msg="- no valid download command found (tried \`curl' and \`wget')."
		else
		    ## use wget
		    cmd_download="${cmd_wget}"
		fi
	    else
		## use curl
		cmd_download="${cmd_curl}"
	    fi
	    ;;
    esac
    ## exit with error if applicable
    if [[ "${err_msg}x" != "x" ]]; then
	err_exit "${err_msg}" "4"
    fi
}

function rawurlencode() {
    ## Source:
    ## http://stackoverflow.com/questions/296536/how-to-urlencode-data-for-curl-command
    local string="${1}"
    local strlen=${#string}
    local encoded=""
    local pos c o
    for (( pos=0 ; pos<strlen ; pos++ )); do
	c=${string:$pos:1}
	case "$c" in
            [-_.~a-zA-Z0-9])
		o="${c}"
		;;
            *)
		printf -v o '%%%02x' "'$c"
	esac
	encoded+="${o}"
    done
    printf "%s" "${encoded}"
}

function get_fontsdirectory() {
    ## check the user specified directory for storing the fontfiles in
    ## arg_fonts_dir and create it if neccessary, or create a
    ## temporary directory.
    ## returns the path to the directory, or an error with description.
    declare -a a_errmsg_fontsdirectory
    msg=
    if [[ "${arg_fonts_dir}x" == "x" ]]; then
	## no font directory specified, create a temporary one
	arg_fonts_dir="$(mktemp -dt ${APP_NAME}.XXXX)"
	if [[ $? -ne 0 ]]; then
	    a_errmsg_fontsdirectory+=("- could not create a temporary font directory.")
	fi
    else
	## font directory specified, check if it is exists
	if [[ ! -d "${arg_fonts_dir}" ]]; then
	    ## it doesn't, create it
	    res="$(LANG=C mkdir -pv "${arg_fonts_dir}" 2>&1)"
	    if [[ $? -ne 0 ]]; then
		a_errmsg_fontsdirectory+=("- error creating font directory '${arg_fonts_dir}':")
		a_errmsg_fontsdirectory+=("   ${res}")
	    fi
	else
	    ## it does, check if it's writable
	    if [[ ! -w "${arg_fonts_dir}" ]]; then
		a_errmsg_fontsdirectory+=("- specified directory '${arg_fonts_dir}' is not writable.")
	    fi
	fi
    fi
    if [[ ${#a_errmsg_fontsdirectory[@]} -gt 0 ]]; then
	## return the error descriptions to the calling function
	printf "%s\n" "${a_errmsg_fontsdirectory[@]}"
	return 1
    else 
	## no errors; return the path of the directory
	printf "%s" "${arg_fonts_dir%%/}"
    fi
}

function display_usageinfo() {
    help_type="$1"

    msg_help_header_basic="Usage:
   ${APP_NAME} FONTSPEC
   -or-
   ${APP_NAME} [optional arguments] FONTSPEC
"
    msg_help_header_advanced="Usage:
   ${APP_NAME} FONTSPEC
   -or-
   ${APP_NAME} \\
        [-o|--outputfile PATH] [-d|--fontdirectory PATH] \\
        [-i|--incss-fontpath PATH] \\
 	[-w|${label_overwrite_all} | [${label_overwrite_css}] [${label_overwrite_fonts}]] \\
        [-f|--formats FORMATSPEC] [-s|--subsetspec SUBSETSPEC] \\
        [-n|--skip-downloads] [-x|${label_skip_localsrc}] \\
        [${label_includechrome}] [-v|${label_verbose}] \\
        [-h|--help] \\
        FONTSPEC
"
    msg_help_defaultusage="
  The script generates a valid CSS @font-face rule for the
  given FONTSPEC(s), prints it to stdout, and downloads the font files
  to a temporary directory."

    msg_help_exitcodes="
  EXIT CODES Errors and warnings are printed to stderr, so it should
  be save to redirect the output, which always is css. The script
  returns the following exit codes on errors:
  - 1: Invalid FONTSPEC
  - 2: I/O error (handling directories and files)
  - 3: Download error
  - 4: Invalid argument (other than FONTSPEC)
  - 5: None of the above"

    msg_help_arguments_basic="
OPTIONAL ARGUMENTS
  -o|--outputfile PATH     Path to the file to save the CSS in.
  -d|--fontdirectory PATH  Path to the directory to download fonts to.
  -i|--incss-fontpath PATH Path used to reference font files within the css.
  -w|${label_overwrite_all}              Overwrite existing font and css files."

    msg_help_arguments_advanced="${msg_help_arguments_basic}
  ${label_overwrite_css}          Overwrite existing css file.
  ${label_overwrite_fonts}        Overwrite existing font files.
  -f|--formatspecs FORMATSPEC Comma-separated list of FORMATSPECs.
  -s|--subsetspecs SUBSETSPEC Comma-separated list of SUBSETs.
  -n|--no-downloads        Prevents the script from downloading web fonts.
  --include-chrome         Adds css comments indicating where the
                           script generated css starts and ends.
  -x|${label_skip_localsrc}          Prevents the inclusion of the 'local()' values.
  -v|${label_verbose}             Be more verbose.
  -h|--help                Show simple help message and exit."

        msg_help_fontspec="
  FONTSPEC should be space separated list of font families, with an
  optional \`:' suffix and a comma separated list of
  font weight/style values. For regular \`Roboto' and regular and
  bold-italic \`Open Sans', use:
   best-served-local Roboto  \"Open Sans:regular,bolditalic\""
    msg_help_formatspec="
  FORMATSPEC (optional) should be one of the following presets, taken
  from https://css-tricks.com/snippets/css/using-font-face/:
  - \`superprogressive': \`woff2'
  - \`practical':        superprogressive + \`woff'
  - \`slightlydeeper':   practical + \`ttf'
  - \`all':              all of the above + \`odt' and \`svg'.
  It defaults to \`practical'."
    msg_help_subsetspec="
  SUBSETSPEC (optional) is one of \`cyrillic', \`cyrillic-ext,
  \`greek', \`greek-ext', \`latin', \`latin-ext',
  \`vietnamese' or \`all', and defaults to \`latin'."
    msg_help_more_basic="
  For extensive documentation and usage examples, run:
   ${APP_NAME} --advanced-help
  Or see:
   ${APP_URL}"
    msg_help_more_advanced="
  For extensive documentation, more usage and automation examples, see:
   ${APP_URL}"
    msg_help_footer="
  ${APP_NAME} Copyright (C) 2016 Ronald van Engelen (See LICENSE).
  License GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>
  This is free software: you are free to change and redistribute it.
  There is NO WARRANTY, to the extent permitted by law."

    msg_help_advanced="${msg_help_header_advanced}
${msg_help_arguments_advanced}
${msg_help_defaultusage}
${msg_help_fontspec}
${msg_help_formatspec}
${msg_help_subsetspec}
${msg_help_exitcodes}
${msg_help_more_advanced}
${msg_help_footer}
"
    msg_help_basic="${msg_help_header_basic}\
${msg_help_arguments_basic}
  ...                      More advanced options available (show with -hh)
  -hh|--advanced-help      Show help on advanced options and exit.
${msg_help_defaultusage}
${msg_help_fontspec}
${msg_help_more_basic}
${msg_help_footer}
"
    case "${help_type}x" in
    "basic"*|"x")
	printf 1>&2 "%s\n" "${msg_help_basic}"
	;;
    "advanced"*)
	printf 1>&2 "%s\n" "${msg_help_advanced}"
	;;
    esac
    exit
}


function err_invalid_arg() {
    ## handle invalid value $2 forargument $1. returns (too?)
    ## descriptive string to calling function. Formatting of string is
    ## done by calling function.
    argument="$1"
    value="$2"
    msg=
    a_labels=()
    if [[ "${value}x" == "x" ]]; then
	msg="Invalid (empty) value"
    else
	msg="Invalid value \`${value}'"
    fi
    msg+=" for argument \`--${argument}' specified."
    case ${argument#-*} in
	f|format|arg_formatspecs)
	    msg+="Should be one of the presets \`superprogressive', \`practical',
\`slightlydeeper' or \`all', or one or more of the raw formats "
	    a_labels=(${valid_formatspecs[@]:0:$(( ${#valid_formatspecs[@]} - 1 ))})
	    values="$(printf "\`%s', " "${a_labels[@]}")"
	    values+=" or \`${valid_formatspecs[-1]}'."
	    msg+="${values}"
	    ;;
	l|subsets*|arg_subsetspecs)
	    msg+="Should be 'all', or one or more of "
	    ## slice the last element ('all') from the array
	    a_labels=(${valid_subsetspecs[@]:0:$(( ${#valid_subsetspecs[@]} - 2 ))})
	    values="$(printf "\`%s', " "${a_labels[@]}")"
	    values+="
or \`${valid_subsetspecs[-1]}'."
	    msg+="${values}"
	    ;;
	i|incss-fontpath)
	    msg+="Should be a string."
	    ;;
	o|outputputfile)
	    msg+="Should be the path of a file."
	    ;;
	d|fontdirectory)
	    msg+="Should be the path of a directory."
	    ;;
    esac
    # shellcheck disable=SC2059
    printf "${msg}"
}


function analyze_commandline_args() {
    ## parse command line arguments using the `manual loop` method
    ## described in http://mywiki.wooledge.org/BashFAQ/035.
    while :; do
        case "${1}" in
            -o|--outputfile)
		if [[ -n "${2:-}" ]]; then
		    arg_output_cssfile="${2}"
		    shift 2
                    continue
		else
		    err_invalid_arg "$1" "$2"		    
                    return 1
		fi
		;;
            -d|--fontdirectory)
		if [[ -n "${2:-}" ]]; then
		    arg_fonts_dir="${2}"
		    shift 2
                    continue
		else
		    err_invalid_arg "$1" "$2"		    
		    return 1
		fi
		;;
            -i|--incss-fontpath)
		if [[ -n "${2:-}" ]]; then
		    arg_incss_fontsdir="${2}"
		    if [[ "${arg_incss_fontsdir:0:1}" == '-' ]]; then
			err_invalid_arg "$1" "$2"
			return 1
		    fi
		    shift 2
                    continue
		else
		    err_invalid_arg "$1" "$2"		    
		    return 1
		fi
		;;
	    -s|--subsets*|-l)
		## -l for compatibility with google-font-download from neverpanic
		if [[ -n "${2:-}" ]]; then
		    arg_subsetspecs="${2}"
		    shift 2
                    continue
		else
		    err_invalid_arg "$1" "$2"
		    return 1
		fi
		;;
	    -f|--formats*)
		if [[ -n "${2:-}" ]]; then
		    arg_formatspecs="${2}"
		    shift 2
                    continue
		else
		    err_invalid_arg "$1" "$2"		    		    
		    return 1
		fi
		;;
	    -n|--no-downloads)
		if [[ -n "${2:-}" ]]; then
		    arg_skipdownload=True
		    shift
		    continue
		else
		    shift	    
		fi
		;;
	    -x|"${label_skip_localsrc}"*)
		if [[ -n "${2:-}" ]]; then
		    arg_skiplocal=True
		    shift
		    continue
		else
		    shift
		fi
		;;
	   "${label_overwrite_css}"*)
		if [[ -n "${2:-}" ]]; then
		    arg_overwrite_css=True
		    shift
		    continue
		else
		    shift
		fi
		;;
	    "${label_overwrite_fonts}"*)
		if [[ -n "${2:-}" ]]; then
		    arg_overwrite_fonts=True
		    shift
		    continue
		else
		    shift
		fi
		;;
	    -w|"${label_overwrite_all}")
		if [[ -n "${2:-}" ]]; then
		    arg_overwrite_fonts=True
		    arg_overwrite_css=True
		    shift
		    continue
		else
		    shift
		fi
		;;
	    "${label_includechrome}")
		if [[ -n "${2:-}" ]]; then
		    arg_opt_includechrome=True
		    shift
		    continue
		else
		    shift
		fi
		;;
	    -v|"${label_verbose}")
		printf 1>&2 "verbose on\n"
		if [[ -n "${2:-}" ]]; then
		    arg_opt_verbose=True
		    shift
		    continue
		else
		    shift
		fi
		;;
	    -h|-\?|--help) 
		display_usageinfo "basic"
		exit
		;;
	    -hh|--advanced-help)
		display_usageinfo "advanced"
		exit
		;;
            --)
		## comma separated list of fonts (eg
		## 'font:weight(slant) font2:weight(slant)')
		shift
		break
		;;
	   -?*)
	       printf 1>&2 "Notice: unknown option \`%s' ignored\n\n" "$1"
               display_usageinfo
	       exit
               ;;
           *)
               break
        esac
    done
    ## shift the options index to get the remainder of the command
    ## line arguments containing the font descriptions
    ## and return them as 0-separated strings.
    shift $((OPTIND - 1))
    arg_fontspecs="$(printf "%s\n" "$@")"
    if [[ "${arg_fontspecs}x" == "x" ]]; then 
	err_exit "not a single FONTSPEC specified." "1"
    fi
    pipes_in_arg=0
    pipes_in_arg=${arg_fontspecs//[^|]}
    if [[ ${#pipes_in_arg} -gt 0 ]] || \
	   [[ "${arg_fontspecs}" =~ ${goggle_html_link_re} ]] || \
	   [[ "${arg_fontspecs}" =~ ${goggle_js_import_re} ]]       ; then
	## fontspec contains at least a pipe symbol: it probably is the value of the href-attribute of
	## an html link-element, eg. 'WebfontA:100|WebfontB:italic')
	if [[ "${arg_fontspecs}" =~ ${goggle_html_link_re} ]] \
	       || [[ "${arg_fontspecs}" =~ ${goggle_js_import_re} ]]; then
	    ## the FONTSPEC contains the Google font url; strip it
	    re_match="${BASH_REMATCH[1]}"
	    ## convert any plus sign to space
	    re_match="${re_match//+/ }"
	    arg_fontspecs="$(htmlcsslink_to_fontspeclist "${re_match}")"
	else
	    arg_fontspecs="$(htmlcsslink_to_fontspeclist "${arg_fontspecs}")"
	fi
    fi 
}

function htmlcsslink_to_fontspeclist() {
    ## convert the href-attribute of an html link-element ($1) to a
    ## FONTSPEC list and return it to the calling function.
    fontspecs="${1:-}"
    fontspecs="${fontspecs//|/;}"
    IFS=\;
    for fontspec in ${fontspecs}; do 
	printf "%s\n" "${fontspec}"
    done
}


function generate_css() {
    ## return a complete font-face css rule
    cssattr_font_family="$1"
    cssattr_font_style="$2"
    cssattr_font_weight="$3"
    cssattr_src_local_nonps="$4"
    cssattr_src_local_ps="$5"
    cssattr_src_urlformats="$6"
    eot_src_attr="${7}"
    ## start the output template
    font_face_template="\
@font-face {
   font-family: '%s';
"
    ## check if the special ie9 quirk workaround should be applied
    if [[ "${eot_src_attr}x" != "x" ]]; then
	font_face_template+="$(printf "   %s\n" "${eot_src_attr}")"
    fi
    ## construct array to hold complete src attribute
    a_src_attrs=()
    ## check if the local property/properties should be set
    if [[ "${arg_skiplocal}x" == "x" ]]; then
	## skip 'local' argument not set
	if [[ "${cssattr_src_local_nonps}x" != "x" ]]; then
	    ## add 'local' non-postscript font name
	    src_local_attrs+=("local('${cssattr_src_local_nonps}')")
	fi 
	if [[ "${cssattr_src_local_ps}x" != "x" ]]; then
	    ## add 'local' postscript name
	    src_local_attrs+=("local('${cssattr_src_local_ps}')")
	fi
	if [[ ${#src_local_attrs[@]} -gt 0 ]]; then
	    ## convert array into comma separated string
	    src_local_line="$(printf "%s, " "${src_local_attrs[@]}")"
	    ## add each of the 'local' properties to the template
	    #font_face_template+="${src_local_line}"
	    ## add it it to array
	    a_src_attrs=("${src_local_line}")
	fi 
    fi
    ## append the 'url() format()' lines
    while read -r line; do
	a_src_attrs+=("${line}");
    done<<<"${cssattr_src_urlformats}"
    font_face_template+="   src:         ${a_src_attrs[0]}\n"
    font_face_template+="$(printf "                %s\n" "${a_src_attrs[@]:1}")"
    ## add the rest of the template (spaces are important for final formatting)
    font_face_template+="
   font-style:  %s;
   font-weight: %s;\n}"
    ## return the complete filled-in css template to the calling
    ## function
    # shellcheck disable=SC2059
    printf "${font_face_template}" \
   "${cssattr_font_family}" \
   "${cssattr_font_style}" \
   "${cssattr_font_weight}"
}


function download_fontfile() {
    ## download the font file using $1 from url $2, save it locally in
    ## directory ${checked_dir} with filename $3.
    ## returns file name on success, error 1 with filename when font file exists, 
    cmd_download="$1"
    url="$2"
    output_file_path="$3"
    local download_args=()
    ## see if an existing font file should be overwritten
    if [[ -f "${output_file_path}" ]] && [[ "${arg_overwrite_fonts}x" == "x" ]]; then
	## return the filename and a specific error
	printf "%s" "${output_file_path}"
	return 1
    fi
    if [[ "${cmd_download}" == "${cmd_wget}" ]]; then
	## use wget
	download_args=(-O "${output_file_path}")
	download_args+=("${url}")
    else
	## use curl
	download_args=(--get)
	download_args+=(--silent)
	download_args+=(--verbose)
	download_args+=(--show-error)
	download_args+=(--fail)
	download_args+=("${url}")
	download_args+=(-o "${output_file_path}")
    fi
    res="$(LANG=C ${cmd_download} "${download_args[@]}" 2>&1 &)"
    ## exit code of backgrounded task can't be trapped easily; instead
    ## rely on existance of outputfile
    download_pid=$!
    if [[ ! -f "${output_file_path}" ]]; then
	## in case of error wait for the exit of the pid of the
	## cmd_download (we hope)
	wait ${download_pid}
	ret=$?
	processchain="$(printf "%s<-" "${FUNCNAME[@]}")"
	printf "%s: %s error %s downloading font:\n%s\n" \
	       "${processchain}" "${cmd_download}" "${ret}" "${res}"
	return 2
    else
	## downloaded succesfully; return the path to the font file
	printf "%s" "${output_file_path}"
    fi
}


function httpget_atrule_google() {
    ## Validates the chosen combination of font and language subset at
    ## google using curl or wget, and returns the resulting font-face
    ## atrule to the calling function, or, if the format ($5) is
    ## specified, retrieve the download url for the font.
    ## Exits with descriptive error when no success.
    ## In the second iteration ("${formatspec}x" != "x") the fonts'
    ## file format is specified, which will be used to mimic a certain
    ## user agent to get the proper FORMATSPEC.
    ## see https://developers.google.com/fonts/docs/technical_considerations#what_is_the_google_fonts_api_serving
    cmd_download="$1"
    fontname="$2"
    fontstyleweight="$3"
    local subsetspec="$4"
    local formatspec="${5:-}" ## only used in the second iteration
    fontfamily="${fontname}:${fontstyleweight}"
    unset download_args
    local download_args=()
    if [[ "${cmd_download}" == "${cmd_wget}" ]]; then
	## use wget
	download_args=(-O "-")
	## depend on wgets' builtin url-encoding
	str_postdata="family=${fontfamily}&subset=${subsetspec}"
	if [[ "${formatspec}x" != "x" ]]; then
	    download_args+=(--user-agent="'${useragent[${formatspec}]}'")
	fi
	## needed for making wget understand option arguments stop,
	## and url starts
	download_args+=(--)
	download_args+=("${GOOGLE_FONTAPI_URL}?${str_postdata}")
    else
	## use curl
	download_args=(--get)
	download_args+=(--silent)
	download_args+=(--show-error)
	download_args+=(--fail)
	## depend on curls' builtin url-encoding
	download_args+=(--data-urlencode "family=${fontfamily}")
	download_args+=(--data-urlencode "subset=${subsetspec}")
	if [[ "${formatspec}x" != "x" ]]; then
	    download_args+=(--user-agent "'${useragent[${formatspec}]}'")
	fi
	download_args+=("${GOOGLE_FONTAPI_URL}")
    fi
    ## run downloader as background task, which means we can't trap
    ## it's exit code so trap '400 Bad Request' output
    badrequest_re="400 Bad Request"
    cssattr_font_face="$(LANG=C ${cmd_download} "${download_args[@]}" 2>&1 &)"
    if [[ "${cssattr_font_face}" =~ ${badrequest_re} ]]; then
	processchain="$(printf "%s<-" "${FUNCNAME[@]}")"
	printf "%s: error %s using %s:\n%s\n" \
	       "${processchain}" "${ret}" "${cmd_download}" "${cssattr_font_face}"
	return 1
    else
	## return the complete font-face atrule
	printf "%s" "${cssattr_font_face}"
    fi
}


function validate_arg_formatspec() {
    ## validate the FORMATSPEC specified by the user in $1 against
    ## valid_formatspecs.
    ## returns error if no argument could be validated.
    ## convert comma separated arguments into array
    a_formatspecs=( ${1//,/ } )
    case "${a_formatspecs[@]}x" in 
	allx)
     	    ## argument is 'all'; add all available formats to array
	    a_checked_formatspecs=( ${valid_formatspecs[@]} )
	    ;;
	x|practicalx)
	    ## argument is empty or 'practical'
	    a_checked_formatspecs=( ${practical_formatspecs[@]} )
	    ;;
	*deeper*x)
	    a_checked_formatspecs=( ${slightlydeeper_formatspecs[@]} )
	    ;;
	*progressive*x)
	    a_checked_formatspecs=( ${superprogressive_formatspecs[@]} )
	    ;;
	*)
	    ## user specified FORMATSPECS, try to iterate the array
	    # shellcheck disable=SC2068
	    for formatspec in ${a_formatspecs[@]}; do
		if [[ "${formatspec}x" == "allx" ]]; then
		    a_checked_formatspecs+=( ${valid_formatspecs[@]} )
		    continue
		else
		    # shellcheck disable=SC2076
		    if [[ ${valid_formatspecs[@]} =~ "${formatspec}" ]]; then
			a_checked_formatspecs+=( "${formatspec}" )
		    else
			## invalid FORMATSPEC specified
			err_invalid_arg "format" "${formatspec}"
		    fi
		fi
	    done
	    ;;
    esac
    if [[ ${#a_checked_formatspecs[@]} -eq 0 ]]; then
	## return error	
	return 1
    else
	## return the array as a space separated list
	printf "%s " "${a_checked_formatspecs[@]}"
    fi
}


function validate_arg_subsetspec() {
    ## validate the SUBSETSPEC specified by the user in $1
    ## against valid_subsetspecs.
    ## returns error if no choice could be validated.
    ## convert comma separated arguments into array
    a_subsetspecs=( ${1//,/ } )
    if [[ "${a_subsetspecs[@]}" =~ all ]]; then
	## when 'all' is chosen skip any other
	a_checked_subsetspecs+=( "all" )
    else
	# shellcheck disable=SC2068,SC2076
	for subsetspec in ${a_subsetspecs[@]}; do
	    if [[ ${valid_subsetspecs[@]} =~ "${subsetspec}" ]]; then   
		a_checked_subsetspecs+=("${subsetspec}")
	    else
		err_invalid_arg "subsetspecs" "${subsetspec}"
	    fi
	done
    fi
    ## return error
    if [[ ${#a_checked_subsetspecs[@]} -eq 0 ]]; then
	return 1
    else
	## return space separated string with valid SUBSETSPECS
	printf "%s " "${a_checked_subsetspecs[@]}"
    fi
}


function process_atrule() {
    ## process the supplied fontface atrule ($1), by extracting all
    ## its attributes, adding the font file name and url for each
    ## FORMATSPEC/SUBSETSPEC to the a_downloads array, and storing the
    ## resulting css in the temporary variable 'temp_atrule'.
    cssattr_font_face="$1"
    cssattr_font_family=""
    cssattr_font_weight=""
    cssattr_font_style=""
    cssattr_src=""	
    cssattr_src_local_nonps=
    cssattr_src_local_ps=
    cssattr_src_url=
    ## initialize for later use
    download_url=
    font_version=""
    a_url_format_attrs=()
    ## setup regular expressions to match css attributes and to
    ## determine their values
    re_font_family="font-family:[[:space:]]*'(.*)';"
    re_font_weight="font-weight:[[:space:]]*(.*);"
    re_font_style="font-style:[[:space:]]*(.*);"
    re_src="src:[[:space:]]*(.*);"
    re_src_local="local\([']?(.*)[']?\)"
    ## matches only the url value 'url(...)' not the optional trailing
    ## 'format(...)'
    re_src_url="url\(([^[:space:]]*)\)"
    re_src_url_version="/(v[0-9]*)/"
    ## process the (newline separated) font-face atrule
    while read -r line; do
	if [[ "${line}" =~ ${re_font_family} ]]; then
	    ## font-family attribute
	    cssattr_font_family="${BASH_REMATCH[1]}"
	elif [[ "${line}" =~ ${re_font_weight} ]]; then
	    ## font-weight attribute
	    cssattr_font_weight="${BASH_REMATCH[1]}"
	elif [[ "${line}" =~ ${re_font_style} ]]; then
	    ## font-style attribute
	    cssattr_font_style="${BASH_REMATCH[1]}"
	elif [[ "${line}" =~ ${re_src} ]]; then
	    ## src attribute
	    cssattr_src="${BASH_REMATCH[1]}"	
	fi
    done<<<"${cssattr_font_face}"
    ## parse the src attribute to extract the 'local' font family
    ## values for both the non-PS and PS family name, and the
    ## 'url(...) format(...)' values for the version of the font
    # shellcheck disable=SC2162
    while IFS=, read local_nonps local_ps url_format; do
	[[ "${local_nonps}" =~ ${re_src_local}  ]] &&
	    cssattr_src_local_nonps="${BASH_REMATCH[1]}"
	[[ "${local_ps}" =~ ${re_src_local} ]] && \
	    cssattr_src_local_ps="${BASH_REMATCH[1]}"
	[[ "${url_format}" =~ ${re_src_url} ]] && \
	    cssattr_src_url="${BASH_REMATCH[1]}"
    done<<<"${cssattr_src}"
    ## remove single quotes if any
    cssattr_src_local_nonps="${cssattr_src_local_nonps//\'/}"
    cssattr_src_local_ps="${cssattr_src_local_ps//\'/}"
    ## create a label for saving and referencing the font file
    if [[ "${cssattr_src_local_nonps}x" == "x" ]]; then
	## local attribute not set; use the font family
	base_localname="${cssattr_font_family}"
    else
	## use the escaped local (non PS) attribute
	base_localname="${cssattr_src_local_nonps}"
    fi
    base_localname="${base_localname// /_}"
    ## try to get the version from the url, otherwise leave empty
    if [[ "${cssattr_src_url}" =~ ${re_src_url_version} ]]; then
	font_version="${BASH_REMATCH[1]}_"
    fi
    ## process each FORMATSPEC/SUBSETSPEC
    # shellcheck disable=SC2068
    for formatspec in ${a_checked_formatspecs[@]}; do
	# shellcheck disable=SC2068
	for subsetspec in ${a_checked_subsetspecs[@]}; do
	    add_eot_src_attr=
	    cssattr_font_face="$(httpget_atrule_google \
	    "${cmd_download}" \
	    "${cssattr_font_family}" \
	    "${cssattr_font_weight}${cssattr_font_style}" \
	    "${subsetspec}" \
	    "${formatspec}")"
	    if [[ $? -ne 0 ]]; then
		processchain="$(printf "%s<-" "${FUNCNAME[@]}")"
		err_exit "ANOMALITY ${processchain}:
${cssattr_font_face}"
	    fi
	    ## determine and set the filename's extension, suffix
	    ## (part after the extension) and other quirk workarounds
	    suffix=
	    label_format="${formatspec}"
	    extension="${formatspec}"
	    case ${formatspec} in
		ttf|truetype)
		    ## replace 'ttf' with 'truetype' if applicable
		    label_format="truetype"
		    extension="ttf"
		    ;;
		svg*)
		    ## agents capable of using svg(z) fonts, gather the
		    ## font family from the suffix after the extension
		    ## and a hash sign with spaces removed, eg.
		    ## 'fontfile.ext#FontFamily'.
		    suffix="#${cssattr_font_family// /}"
		    ;;
		eot*|embedded-opentype)
		    ## 'fontfile.ext?iefix'.
		    label_format="embedded-opentype"
		    suffix="?iefix"
		    add_eot_src_attr=True
		    ;;
		otf*|opentype)
		    ## 'fontfile.ext?iefix'.
		    label_format="opentype"
		    ;;		
	    esac
	    ## construct the filename
	    if [[ "${base_localname}x" == "x" ]]; then
		err_exit "ANOMALITY: empty base_localname; this should not happen."
	    else
		filename="${base_localname}_${font_version}${subsetspec}_${cssattr_font_weight}.${extension}"
	    fi
   	    url_format_template="        url('%s') format('%s'),\n"
	    url_format_template="url('%s') format('%s'),\n"
	    if [[ "${arg_incss_fontsdir}x" != "x" ]]; then
		filename="${arg_incss_fontsdir%%/}/${filename}"
	    fi
	    if [[ "${add_eot_src_attr}x" != "x" ]] && [[ "${formatspec}" = "eot" ]]; then
		## prepend the final src variable with the ie9 quirk workaround
		eot_src_attr="src:         url('${filename}');\n"
	    fi
	    # shellcheck disable=SC2059
	    a_url_format_attrs+=("$(printf "${url_format_template}" \
"${filename}${suffix}" "${label_format}")")
	    if [[ "${arg_skipdownload}x" == "x" ]]; then
		## download the web font(s)
		## get the url for this FORMATSPEC/SUBSETSPEC
    		if [[ "${cssattr_font_face}" =~ ${re_src_url} ]]; then
		    download_url="${BASH_REMATCH[1]}"
		else
		    printf 1>&2 "BUG: can't extract url from src attribute=\`%s'\n" \
				"${cssattr_font_face}"
		    ## try the next subsetspec
		    continue
		fi
		## add an array item
		a_downloads[${filename}]="${download_url}"
	    fi
	done 
    done
    ## convert array to multi-lined string
    cssattr_src_urlformats="$(printf "%s\n" "${a_url_format_attrs[@]}")"
    ## replace last comma with semi-colon
    cssattr_src_urlformats="${cssattr_src_urlformats%?};"
    ## generate the atrule and add it to the temp variable
    res=$(generate_css \
	      "${cssattr_font_family}" \
	      "${cssattr_font_style}" \
	      "${cssattr_font_weight}" \
	      "${cssattr_src_local_nonps}" \
	      "${cssattr_src_local_ps}" \
	      "${cssattr_src_urlformats}" \
	      "${eot_src_attr}")
    temp_atrule="$(printf "%s\n" "${res}")"
}


function create_atrules() {
    ## process each item in the fontspecs array, create the proper css
    ## atrule for it and store it in the a_atrules_created array.
    ## setup basic regexp matching
    family_re="(.*):(.*)"
    for family in "${a_arg_fontspecs[@]}"; do
	if [[ "${family}" =~ ${family_re} ]]; then
	    fontname="${BASH_REMATCH[1]}"
	    ## construct array from second match, by replacing commas
	    ## (if any) by spaces to get the requested font styles
	    styles=( ${BASH_REMATCH[2]//,/ } )
	else
	    ## font spec without style; append 'regular'
	    fontname="${family}"
	    styles=( regular )
	fi
	## iterate the array and process each name/style pair
	for fontstyle in "${styles[@]}"; do
	    ## check the validity of the specified name/value pair
            ## (eg. 'Font_Name:weightx,weighty') and get and return it's
	    ## font-face atrule
	    atrule="$(httpget_atrule_google \
"${cmd_download}" \
"${fontname//\'/}" \
"${fontstyle//\'/}" \
"${a_checked_subsetspecs[@]}")"
	    if [[ $? -ne 0 ]]; then
		## add the invalid specification to the array
		a_invalid_specs+=("- '${fontname}:${fontstyle}'" )
	    else
		## process the fontface atrule for the chosen fontname:fontstyle
		## the result is stored in temp_atrule
		temp_atrule=""
		process_atrule "${atrule}"
		if [[ $? -ne 0 ]]; then
		    printf 1>&2 "BUG: error processing atrule:\n%s\nerror was:\n''\n" \
			   "${atrule}" "${res}"
		    return 1
		else
		    ## add the atrule for this fontspec to the array
		    a_atrules_created+=("$(printf "%s\n" "${temp_atrule}")")
		fi
	    fi
	done
    done
    
}

## path to css file
arg_output_cssfile="${arg_output_cssfile:-}"
## font download directory
arg_fonts_dir="${arg_fonts_dir:-}"
## commandline argument -s/--skip-download
arg_skipdownload="${arg_skipdownload:-}"
## commandline argument -x/--skip-local-src-attr
arg_skiplocal="${arg_skiplocal:-}"
## comma separated list of font subsets to be downloaded, defaults to latin
arg_subsetspecs="${arg_subsetspecs:-${DEF_ARG_SUBSETSPECS}}"
## comma separated list of font formats to be downloaded
## defaults to 'practical' (eg 'woff & woff2')
arg_formatspecs="${arg_formatspecs:-${DEF_ARG_FORMATSPECS}}"
arg_overwrite_css="${arg_overwrite_css:-}"
arg_overwrite_fonts="${arg_overwrite_fonts:-}"
arg_opt_includechrome="${arg_opt_includechrome:-}"

## initialize variables for storing validated selections
declare checked_dir
## array to hold the commandline font specification(s)
declare -a a_arg_fontspecs
declare -A a_downloads
declare -a a_checked_formatspecs
declare -a a_checked_subsetspecs
declare -a a_atrules_created
## arrays for messages, errors and counts
declare -a a_msg_inform
declare -a a_invalid_specs
declare -a a_fonts_exists
declare -a a_fonts_download_errors
declare -a a_fonts_skipped
declare -a a_fonts_successes

## valid choices
valid_subsetspecs=(cyrillic cyrillic-ext greek greek-ext latin latin-ext vietnamese all)
valid_formatspecs=(eot otf woff woff2 svg ttf)
## supersets of font formats, taken from:
## https://css-tricks.com/snippets/css/using-font-face/
superprogressive_formatspecs=("woff2")
practical_formatspecs=( ${superprogressive_formatspecs[@]} "woff")    
slightlydeeper_formatspecs=( ${practical_formatspecs[@]} "ttf" )

## use a specific user agent in HTTP requests to Googles font site to get the correct css.
## see: http://www.useragentstring.com/
declare -A useragent="(\
[eot]='Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0)'
[woff]='Mozilla/5.0 (Windows NT 6.1; WOW64; rv:27.0) Gecko/20100101 Firefox/27.0'
[woff2]='Mozilla/5.0 (Windows NT 6.1; WOW64; rv:40.0) Gecko/20100101 Firefox/40.0'
[svg]='Mozilla/4.0 (iPad; CPU OS 4_0_1 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko) Version/4.1 Mobile/9A405 Safari/7534.48.3'
[ttf]='Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.54.16 (KHTML, like Gecko) Version/5.1.4 Safari/534.54.16'
[otf]='Mozilla/5.0 (Windows; U; MSIE 9.0; WIndows NT 9.0; en-US))'\
)"
# shellcheck disable=SC2154
declare -A useragent[svgz]="${useragent[svg]}"

goggle_url_re="['http's]?[s:]?//${GOOGLE_FONTAPI_HOST//./\\\.}/css\?family="
## matching group contains everything upon the next space
goggle_html_link_re="['<link href=\"']?${goggle_url_re}([^[:space:]]*)"
## matching group contains everything upon the next ')'
goggle_js_import_re="['@import url\(']?${goggle_url_re}']?([^\)*)[;]?"

label_overwrite_all="--overwrite"
label_overwrite_css="--overwrite-css"
label_overwrite_fonts="--overwrite-fonts"
label_includechrome="--include-chrome"
label_verbose="--verbose"
label_skip_localsrc="--skip-local"
if [[ "${0}" =~ /dev/fd.* ]]; then
    ## script loaded from stdin
    label_appname="${APP_NAME}"
else
    label_appname="${0:-APP_NAME}"
fi
## reconstruct cmdline for include-chrome option
cmdline_args_raw="$(printf "%s " "$@" | fmt)"
cmdline_args="$(while read -r line; 
do printf "%s \ \n" "${line}"; 
done< <(printf "%s \n" "${cmdline_args_raw}"))"
## strip last line continuation mark
cmdline_args="${cmdline_args%%\\ }"
css_header="font-face at-rules generated with \
${label_appname} (version ${APP_VERSION}), using command: 
${label_appname} ${cmdline_args}
>>> font-face at-rules start here >>>"
css_footer="<<< generated font-face at-rules end here <<<"

## main program flow
## analyze and store all commandline arguments
printf 1>&2 "args:%s\n" "${#@}"
if [[ ${#@} -eq 0 ]]; then
    printf 1>&2 "no commandline args; check stdin\n"
    ## no commandline args; check stdin
    input=$(test -s /dev/stdin && cat)
    if [[ "${input}x" == "x" ]] ; then 
	## stdin empty: display help (and exit)
	analyze_commandline_args "-h"
    else
	## input supplied through stdin; feed it to analyze_commandline_args
	analyze_commandline_args "$@ ${input}" || exit 1
    fi
else
    printf 1>&2 "commandline args; run analyze_commandline_args\n"
    analyze_commandline_args "$@" || exit 1
fi


#exit
#analyze_commandline_args "$@" || exit 1
## turn FONTSPECs in arg_fontspecs set by analyze_commandline_args
## into an array.
# shellcheck disable=SC2162
while read fontspec; do
    if [[ "${fontspec}x" != "x" ]]; then
	a_arg_fontspecs+=( "${fontspec}" )
    fi
done<<<"${arg_fontspecs}"
if [[ ${#a_arg_fontspecs[@]} -eq 0 ]]; then
    err_exit "not a single valid FONTSPEC found." "1"
fi
## check user specified FORMATSPEC (applicable for all fontspecs)
a_checked_formatspecs=( $(validate_arg_formatspec "${arg_formatspecs}") )
if [[ $? -ne 0 ]]; then
    msg_err=$(printf "%s " "${a_checked_formatspecs[@]}" | fmt)
    err_exit "${msg_err}" "4"
fi
## check commandline SUBSETSPEC (applicable for all fontspecs)
a_checked_subsetspecs=( $(validate_arg_subsetspec "${arg_subsetspecs}") )
if [[ $? -ne 0 ]]; then
    msg_err=$(printf "%s " "${a_checked_subsetspecs[@]}" | fmt)
    err_exit "${msg_err}" "4"
fi
## check which downloader should be used (for checking FONTSPECS and
## downloading fonts).
get_download_cmd

## check the output directory (arg_fonts_dir) if applicable
checked_dir="$(get_fontsdirectory)"
if [[ $? -ne 0 ]]; then
    ## return value contains error message, display it
    err_exit "${checked_dir}" "2"
fi

## for each verified FONTSPEC create a valid atrule stored in a_atrules
create_atrules
ret=$?
if [[ ${ret} -ne 0 ]]; then
    msg="ANOMALITY:
\`create_atrules' returned error \`${ret}'. This should not happen.
Please check the output of the script above and include that if you
decide to file a bug at ${APP_GITHUBURL}."
    err_exit "${msg}"
fi

## check if warnings were produced by create-atrules
## TODO: turn decision about fatality of FONTSPEC errors into a user
## choice (extra commandline argument)
if [[ ${#a_invalid_specs[@]} -gt 0 ]]; then
    ## invalid (or unparsable) FONTSPEC
    a_errmsg_fontfile+=("could not process all font specifications.")
    a_errmsg_fontfile+=("- the following FONTSPECs contained errors:")
    a_errmsg_fontfile+=("$(printf " %s\n" "${a_invalid_specs[@]}")")
fi
## check if valid atrules were created; if not exit with error
if [[ ${#a_atrules_created[@]} -le 0 ]]; then
    str_fontspecs="$(printf "'%s', " "${a_arg_fontspecs[@]}")"
    str_fontspecs=${str_fontspecs%%, }
    if [[ ${#a_arg_fontspecs[@]} -gt 1 ]]; then
	msg="none of your FONTSPECs (${str_fontspecs}) could be
validated. Please correct them and try again.
Tip: you might try to lookup the proper FONTSPEC using
${GOOGLE_FONTS_URL}."
    else
	msg="your FONTSPEC (${str_fontspecs}) \
could not be validated. "
	str_fontspecs="${str_fontspecs//\'/}"	
	str_fontspecs="$(rawurlencode "${str_fontspecs}")"
	url="${GOOGLE_FONTS_URL}?query=${str_fontspecs}"
	msg+="Please correct it and try again.
Tip: you might try to lookup the proper FONTSPEC using \"${url}\"."
    fi
    err_exit "$(echo "${msg}" | fmt -s)" "1"
fi

## check if a css output file is specified, if so if it exists,
## and whether it should be overwritten
if [[ "${arg_output_cssfile}x" == "x" ]]; then
    ## no css output file specified
    arg_output_cssfile=/dev/stdout
else
    ## css output file specified
    if [[ -f "${arg_output_cssfile}" ]] && \
	   [[ "${arg_overwrite_css}x" == "x" ]]; then
	## css output file already exists and should not be overwritten
	msg="- not overwriting existing css file \`${arg_output_cssfile}' \
(tip: use \`${label_overwrite_css}')."
	a_errmsg_fontfile+=("${msg}" )
	arg_output_cssfile=/dev/stdout
    else
	## css output file does not exist, check the target directory
	cssdir="$(dirname "${arg_output_cssfile}")"
	if [[ -d "${cssdir}" ]]; then
	    ## exisiting target directory
	    if [[ ! -w "${cssdir}" ]]; then
		a_errmsg_fontfile+=("- directory \`${cssdir}' is not writable.")
		arg_output_cssfile=/dev/stdout
	    fi
	else
	    ## non-exisiting target directory, create it
	    res="$(mkdir -p "${cssdir}" 2>&1)"
	    if [[ $? -ne 0 ]]; then
		a_errmsg_fontfile+=("- can create directory \`${cssdir}'.")
		arg_output_cssfile=/dev/stdout			
	    fi
	fi 
    fi
fi

## valid FONTSPEC(s) found, start writing css output
## TODO: turn decision about fatality of download errors into a user
## choice (extra commandline argument)
## check if css headers should be included
if [[ "${arg_opt_includechrome}x" == "x" ]]; then
    ## not; check if generated css should be generated
    if [[ "${arg_output_cssfile}x" == "x" ]]; then
	## not; print the header to stdout
	echo "${css_header}" | fmt -s 1>&2
    else
	## clear the output_cssfile
	if [[ -f "${arg_output_cssfile}" ]] && [[ "${arg_output_cssfile}" != "/dev/stdout" ]]; then
	    rm "${arg_output_cssfile}"
	fi
    fi
else
    ## it should; prepend header as commented css and create or
    ## overwrite output_cssfile
    printf "/* %s */\n" "${css_header}" > "${arg_output_cssfile}"
fi
## print real css
for atrule in "${a_atrules_created[@]}"; do 
    printf "%s\n" "${atrule}" >> "${arg_output_cssfile}"
done
## check if css footers should be appended/displayed
if [[ "${arg_opt_includechrome}x" == "x" ]]; then
    if [[ "${arg_output_cssfile}x" == "x" ]]; then     
	echo "${css_footer}" | fmt -s 1>&2
    fi
else
    printf "/* %s */\n" "${css_footer}" >> "${arg_output_cssfile}"
fi
## done printing css
## download the font files if applicable
if [[ "${arg_skipdownload}x" != "x" ]]; then
    a_msg_inform+=("- skip downloading of font files as requested.")
else
    [[ "${arg_opt_verbose}x" == "x" ]] || \
	printf 1>&2 "\nDownloading font files to \`%s':" "${checked_dir}"
    for rel_file_path in "${!a_downloads[@]}"; do
	## filename contains arg_incssdir, strip it
	output_file_path="${rel_file_path//${arg_incss_fontsdir}\/}"
	## prepend with absolute path of output directory (checked_dir)
	output_file_path="${checked_dir}/${output_file_path}"
	[[ "${arg_opt_verbose}x" == "x" ]] || \
	    printf 1>&2 "\n%s %-40s " "-" "${output_file_path}"
	if [[ -f "${output_file_path}" ]]; then
	    a_fonts_exists+=("${output_file_path}")
	    [[ "${arg_opt_verbose}x" == "x" ]] || \
		printf 1>&2 " exists   "
	    if [[ "${arg_overwrite_fonts}x" == "x" ]] ; then
		a_fonts_skipped+=("${output_file_path}")
		[[ "${arg_opt_verbose}x" == "x" ]] || \
		    printf 1>&2 "> skipping     > done."
		continue
	    else
		[[ "${arg_opt_verbose}x" == "x" ]] || \
		    printf 1>&2 "> overwriting "
	    fi
	else
	    [[ "${arg_opt_verbose}x" == "x" ]] || \
		printf 1>&2 " new file > downloading "
	fi
	res="$(download_fontfile "${cmd_download}" \
"${a_downloads[${rel_file_path}]}" "${output_file_path}")"
	## consider failed download non-fatal (see TODO above)
	case $? in
	    0)
		a_fonts_successes+=("${res}")
		[[ "${arg_opt_verbose}x" == "x" ]] || \
		    printf 1>&2 " > done."
		;;
	    2)
		## this will probable never be reached, even if download errors occured.
		## instead rely on the count of items in the other arrays
		a_fonts_download_errors+=("${res}")
		[[ "${arg_opt_verbose}x" == "x" ]] || \
		    printf 1>&2 " > error!"
		;;		    
	esac
    done
    nr_fonts_requested=${#a_downloads[@]}
    nr_fonts_downloaded=${#a_fonts_successes[@]}
    nr_fonts_existed=${#a_fonts_exists[@]}
    nr_fonts_skipped=${#a_fonts_skipped[@]}
    nr_fonts_available=$(( nr_fonts_downloaded + nr_fonts_skipped ))
    nr_fonts_missing=$(( nr_fonts_requested - nr_fonts_available ))
    nr_fonts_overwritten=$(( nr_fonts_existed - nr_fonts_skipped  ))
    nr_fonts_new=$(( nr_fonts_downloaded - nr_fonts_overwritten ))
    if (( nr_fonts_missing > 0 )); then
	if (( nr_fonts_missing = nr_fonts_requested )); then
	    a_errmsg_fontfile+=("- none of the ${nr_fonts_missing} font files could be downloaded!")
	else
	    a_errmsg_fontfile+=("- ${nr_fonts_missing} font files could not be downloaded!")
	fi
    else
	if (( nr_fonts_new > 0 )); then
	    a_msg_inform+=("- ${nr_fonts_new} new font files downloaded")
	fi
	## all font files are present
	if (( nr_fonts_existed > 0 )); then
	    ## there were existing font files
	    if (( nr_fonts_skipped > 0 )); then
		## some were skipped (ie not-overwritten)
		a_msg_inform+=("- ${nr_fonts_skipped} existing font files not overwritten (tip: use --overwrite-fonts)")
	    else
		## none were skipped
		if (( nr_fonts_existed > nr_fonts_skipped )); then 
		    ## fonts were overwritten
		    a_msg_inform+=("- ${nr_fonts_overwritten} existing font files overwritten with downloaded version")
		fi
	    fi
	fi
    fi
fi
## display errors/warnings if applicable
## display errors/warnings if applicable
    
if [[ ${#a_msg_inform[@]} -gt 0 ]]; then
    if [[ "${arg_opt_verbose}x" == "x" ]]; then
	printf 1>&2 "%s %s font files available in \`%s'\n" \
		    "-" "${nr_fonts_available}" "${checked_dir}"
    else
	printf 1>&2 "\n\nSummary:\n"
	printf 1>&2 "%s\n" "${a_msg_inform[@]}"
	printf 1>&2 "%s %s font files available in \`%s'\n" \
		    "-" "${nr_fonts_available}" "${checked_dir}"
    fi
fi
if [[ "${arg_opt_verbose}x" != "x" ]]; then 
    if [[ "${arg_output_cssfile}" != "/dev/stdout" ]]; then
	printf 1>&2 "%s css file saved in: \`%s'\n" \
		    "-" "${arg_output_cssfile}"
    else
	printf 1>&2 "%s css file printed to stdout\n" "-"
    fi
fi
if [[ ${#a_errmsg_fontfile[@]} -gt 0 ]]; then
    err_msg="$(printf "%s\n" "${a_errmsg_fontfile[@]}")"
    err_exit "${err_msg}" "1"
else
    [[ "${arg_opt_verbose}x" == "x" ]] || \
	printf 1>&2 "%s all done without errors.\n" "-"
fi

## all done
