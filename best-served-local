#!/usr/bin/env bash

## `best-served-local' is a bash script that helps serving (Google)
## web fonts from your own server, by creating valid css font-face
## atrules and/or downloading the font files.
##
##  Copyright Â© 2016 Ronald van Engelen <ronalde+github@lacocina.nl>
##  This program is free software: you can redistribute it and/or modify
##  it under the terms of the GNU General Public License as published by
##  the Free Software Foundation, either version 3 of the License, or
##  (at your option) any later version.
##
##  This program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##  GNU General Public License for more details.
##
##  You should have received a copy of the GNU General Public License
##  along with this program.  If not, see <http://www.gnu.org/licenses/>.
##
## The script, helpers and documentation are published at 
## https://lacocina.nl/using-best-served-local
##
## Inspired by https://github.com/neverpanic/google-font-download.git and
## https://github.com/neverpanic/google-font-download.git
## 
## Also see `README.md'

## constants and defaults
## font SUBSETSPECS to be downloaded, defaults to 'latin'
## see https://developers.google.com/fonts/docs/getting_started#specifying_script_subsets
DEF_ARG_SUBSETSPECS="latin"
## comma separated list of FORMATSPECS to be downloaded
## defaults to 'practical' (eg 'woff & woff2')
DEF_ARG_FORMATSPECS="practical"
## app defaults
APP_NAME="best-served-local"
APP_VERSION="0.5"
APP_URL="https://lacocina.nl/using-${APP_NAME}"
APP_GITHUBURL="https://github.com/ronalde/best-served-local"
## google constants
GOOGLE_FONTAPI_HOST="fonts.googleapis.com"
GOOGLE_FONTAPI_URL="https://${GOOGLE_FONTAPI_HOST}/css"
GOOGLE_FONTS_URL="https://fonts.google.com/"

function err_exit() {
    ## display fatal error triggered by function $1 with description
    ## $2 and exit with error
    printf 1>&2 "%s\n" "$1"
    printf 1>&2 "Run \`%s -h' to see usage information.\n" \
		"${APP_NAME}"
    exit 1
}

function get_fontsdirectory() {
    ## check the user specified directory for storing the fontfiles in
    ## arg_fonts_dir and create it if neccessary, or create a
    ## temporary directory.
    ## returns the path to the directory, or an error with description.
    declare -a a_msg_err
    msg=
    if [[ "${arg_fonts_dir}x" == "x" ]]; then
	## no font directory specified, create a temporary one
	arg_fonts_dir="$(mktemp -dt ${APP_NAME}.XXXX)"
	if [[ $? -ne 0 ]]; then
	    a_msg_err+=("- could not create a temporary font directory.")
	fi
    else
	## font directory specified, check if it is exists
	if [[ ! -d "${arg_fonts_dir}" ]]; then
	    ## it doesn't, create it
	    res="$(mkdir -pv "${arg_fonts_dir}" 2>&1)"
	    if [[ $? -ne 0 ]]; then
		msg="- unable to create font directory '${arg_fonts_dir}'; "
		msg+="\`mkdir' returned: '${res}'"
		a_msg_err+=("${msg}")
	    fi
	else
	    ## it does, check if it's writable
	    if [[ ! -w "${arg_fonts_dir}" ]]; then
		a_msg_err+=("- specified directory '${arg_fonts_dir}' is not writable.")
	    fi
	fi
    fi
    if [[ ${#a_msg_err[@]} -gt 0 ]]; then
	printf "The following error(s) occured:\n%s\n" "${a_msg_err[@]}"
	return 1
    else 
	## no errors; return the path of the directory
	printf "%s" "${arg_fonts_dir}"
    fi
}

function display_usageinfo() {
    msg="Usage:
   ${APP_NAME} [-o|--outputfile PATH] [-d|--fontdirectory PATH] \\
        [-i|--incss-fontpath PATH] \\
        [-s|--subsetspec SUBSETSPEC] [-f|--formats FORMATSPEC] \\
        [-n|--skip-downloads] [-x|${label_skip_localsrc}] \\
        [${label_overwrite_css}] [${label_overwrite_fonts}] \\
        [${label_overwrite_all}] \\
        [-h|--help] \\
        FONTSPEC

  OPTIONAL ARGUMENTS
  -o|--outputfile PATH     Path to the file to save the CSS in.
  -d|--fontdirectory PATH  Path to the directory to download fonts to.
  -i|--incss-fontpath PATH Path used to reference font files within the css.
  -n|--no-downloads        Prevents the script from downloading web fonts.
  -x|${label_skip_localsrc}          Prevents the inclusion of the 'local()' values.
  -f|--formatspecs FORMATSPECS Comma-separated list of FORMATSPECS.
  -s|--subsetspecs SUBSETSPECS Comma-separated list of SUBSETS.
  ${label_overwrite_css}          Overwrite existing css file.
  ${label_overwrite_fonts}        Overwrite existing font files.
  ${label_overwrite_all}              Overwrite existing font and css files.
  -h|--help                Show this help message and exit.

  With default settings, a CSS Level 3 @font-face atrule is printed to
  stdout and the font files are downloads to a temporary
  directory. Errors and warnings are printed to stderr, so it should
  be save to redirect the output, which always is css.

  FONTSPEC should be space separated list of family names, with
  optional suffix consisting of \`:' with a comma separated list of
  font weight/style values. For example to use \"Open Sans\" in the
  regular font weight and style with the latin subset in the formats
  \`woff' and \`woff2' use:
      ${APP_NAME} \"Open Sans\"

  FORMATSPECS should be one of the following presets, taken
  from https://css-tricks.com/snippets/css/using-font-face/:
  - \`superprogressive': \`woff2'
  - \`practical':        superprogressive + \`woff'
  - \`slightlydeeper':   practical + \`ttf'
  - \`all':              all of the above + \`odt' and \`svg'.

  For extensive documentation and usage examples, see:
  ${APP_URL}

  ${APP_NAME} Copyright (C) 2016 Ronald van Engelen (See LICENSE).
"
    printf 1>&2 "%s\n" "${msg}"
    exit
}


function err_invalid_arg() {
    ## inform user about an invalid value ($2) for commandline argument ($1)
    argument="$1"
    value="$2"
    ## construct string containing valid values for specified argument
    msg_valid="$(msg_valid_argumentvalues "${argument#-*}")"
    case "${value}x" in
	 "x")
	     a_warnings+=("$(printf "\- empty value for argument '%s' specified.\n" \
			 "${argument}")")
	     a_warnings+=("$(printf "%s\n" "${msg_valid}")")
	     ;;
	 "0x")
	     ## special case, return the string to calling function
	     a_warnings+=("$(printf "none of the specified value(s) for argument '%s' are valid.\n" \
		    "${argument}")")
	     a_warnings+=("$(printf "%s\n" "${msg_valid}")")
	     ;;
	 *)
	     a_warnings+=("$(printf "\- invalid value '%s' for argument '%s' specified.\n" \
			 "${value}" "${argument}")")
	     a_warnings+=("$(printf "%s\n" "${msg_valid}")")
	     ;;
    esac
}


function msg_valid_argumentvalues() {
    ## construct and return string with valid values for commandline argument $1
    argument="$1"
    case ${argument#-*} in
	f|format|arg_formatspecs)
	    printf "\tMust be 'superprogressive', 'practical',
	    'slightlydeeper' or 'all', or one or more of "
	    values="$(printf "%s," "${valid_formatspecs[@]}")"
	    printf "%s\n" "${values%*,}"
	    ;;
	l|subsets|arg_subsetspecs)
	    printf "\tMust be 'all' or one or more of: "
	    values="$(printf "%s," "${valid_subsetspecs[@]}")"
	    printf "%s\n" "${values%*,}"
	    ;;
    esac
}


function analyze_commandline_args() {
    ## parse command line arguments using the `manual loop` method
    ## described in http://mywiki.wooledge.org/BashFAQ/035.
    while :; do
        case "${1:-}" in
            -o|--outputfile)
		if [[ -n "${2:-}" ]]; then
		    arg_output_cssfile="${2}"
		    shift 2
                    continue
		else
		    err_invalid_arg "$1" "$2"		    
                    return 1
		fi
		;;
            -d|--fontdirectory)
		if [[ -n "${2:-}" ]]; then
		    arg_fonts_dir="${2}"
		    shift 2
                    continue
		else
		    err_invalid_arg "$1" "$2"		    
		    return 1
		fi
		;;
            -i|--incss-fontpath)
		if [[ -n "${2:-}" ]]; then
		    arg_incss_fontsdir="${2}"
		    shift 2
                    continue
		else
		    err_invalid_arg "$1" "$2"		    
		    return 1
		fi
		;;
	    -s|--subsets*|-l)
		## -l for compatibility with google-font-download from neverpanic
		if [[ -n "${2:-}" ]]; then
		    arg_subsetspecs="${2}"
		    shift 2
                    continue
		else
		    err_invalid_arg "$1" "$2"
		    return 1
		fi
		;;
	    -f|--formats*)
		if [[ -n "${2:-}" ]]; then
		    arg_formatspecs="${2}"
		    shift 2
                    continue
		else
		    err_invalid_arg "$1" "$2"		    		    
		    return 1
		fi
		;;
	    -n|--no-downloads)
		if [[ -n "${2:-}" ]]; then
		    arg_skipdownload=True
		    shift
		    continue
		fi
		;;
	    -x|"${label_skip_localsrc}"*)
		if [[ -n "${2:-}" ]]; then
		    arg_skiplocal=True
		    shift
		    continue
		fi
		;;
	   "${label_overwrite_css}"*)
		if [[ -n "${2:-}" ]]; then
		    arg_overwrite_css=True
		    shift
		    continue
		fi
		;;
	    "${label_overwrite_fonts}"*)
		if [[ -n "${2:-}" ]]; then
		    arg_overwrite_fonts=True
		    shift
		    continue
		fi
		;;
	    "${label_overwrite_all}")
		if [[ -n "${2:-}" ]]; then
		    arg_overwrite_fonts=True
		    arg_overwrite_css=True
		    shift
		    continue
		fi
		;;
	    -h|-\?|--help) 
		display_usageinfo
		exit
		;;
            --)
		## comma separated list of fonts (eg
		## 'font:weight(slant) font2:weight(slant)')
		shift
		break
		;;
	   -?*)
	       printf 1>&2 "Notice: unknown option \`%s' ignored\n\n" "$1"
               display_usageinfo
	       exit
               ;;
           *)
               break
        esac
    done
    ## shift the options index to get the remainder of the command
    ## line arguments containing the font descriptions
    ## and return them as 0-separated strings.
    shift $((OPTIND - 1))
    arg_fontspecs="$(printf "%s\n" "$@")"
    if [[ "${arg_fontspecs}x" == "x" ]]; then 
	err_exit "Error: not a single FONTSPEC specified."
    fi
    pipes_in_arg=0
    pipes_in_arg=${arg_fontspecs//[^|]}
    if [[ ${#pipes_in_arg} -gt 0 ]] || \
	   [[ "${arg_fontspecs}" =~ ${goggle_html_link_re} ]] || \
	   [[ "${arg_fontspecs}" =~ ${goggle_js_import_re} ]]       ; then
	## fontspec contains at least a pipe symbol: it probably is the value of the href-attribute of
	## an html link-element, eg. 'WebfontA:100|WebfontB:italic')
	if [[ "${arg_fontspecs}" =~ ${goggle_html_link_re} ]] \
	       || [[ "${arg_fontspecs}" =~ ${goggle_js_import_re} ]]; then
	    ## the FONTSPEC contains the Google font url; strip it
	    re_match="${BASH_REMATCH[1]}"
	    ## convert any plus sign to space
	    re_match="${re_match//+/ }"
	    arg_fontspecs="$(htmlcsslink_to_fontspeclist "${re_match}")"
	else
	    arg_fontspecs="$(htmlcsslink_to_fontspeclist "${arg_fontspecs}")"
	fi
    fi 
}

function htmlcsslink_to_fontspeclist() {
    ## convert the href-attribute of an html link-element ($1) to a
    ## FONTSPEC list and return it to the calling function.
    fontspecs="${1:-}"
    fontspecs="${fontspecs//|/;}"
    IFS=\;
    for fontspec in ${fontspecs}; do 
	printf "%s\n" "${fontspec}"
    done
}


function generate_css() {
    ## return a complete font-face css rule
    cssattr_font_family="$1"
    cssattr_font_style="$2"
    cssattr_font_weight="$3"
    cssattr_src_local_nonps="$4"
    cssattr_src_local_ps="$5"
    cssattr_src_urlformats="$6"
    eot_src_attr="${7}"
    ## start the output template
    font_face_template="\
@font-face {
   font-family: '%s';
"
    ## check if the special ie9 quirk workaround should be applied
    if [[ "${eot_src_attr}x" != "x" ]]; then
	font_face_template+="$(printf "   %s\n" "${eot_src_attr}")"
    fi
    ## start the src attribute
    font_face_template+="\
   src: \
"
    ## check if the local property/properties should be set
    if [[ "${arg_skiplocal}x" == "x" ]]; then 
	if [[ "${cssattr_src_local_nonps}x" != "x" ]]; then
	    src_local_attrs+=("local('${cssattr_src_local_nonps}')")
	fi 
	if [[ "${cssattr_src_local_ps}x" != "x" ]]; then
	    src_local_attrs+=("local('${cssattr_src_local_ps}')")
	fi
	if [[ ${#src_local_attrs[@]} -gt 0 ]]; then
	    src_local_line="$(printf "%s, " "${src_local_attrs[@]}")"
	    font_face_template+="\
        ${src_local_line}
"
	fi 
    fi
    ## append the rest of the template; the first %s is used to insert
    ## 'url() format()' lines
    font_face_template+="\
%s
   font-style:  %s;
   font-weight: %s;
}
"
    ## return the filled-in template to the calling function
    printf "%s" \
   "${font_face_template} \
   ${cssattr_font_family} \
   ${cssattr_src_urlformats} \
   ${cssattr_font_style} \
   ${cssattr_font_weight}"
}


function download_fontfile() {
    ## download the font file using $1 from url $2, save it locally in
    ## directory ${checked_dir} with filename $3.
    cmd_download="$1"
    url="$2"
    filename="$3"
    local download_args=()
    ## construct the full path
    local outputpath="${checked_dir}/${filename}"
    ## see if an existing font file should be overwritten
    if [[ -f "${outputpath}" ]] && [[ "${arg_overwrite_fonts}x" == "x" ]]; then
	## return the filename and a specific error
	printf "%s" "${outputpath}"
	return 1
    fi
    if [[ "${cmd_download}" == "${cmd_wget}" ]]; then
	## use wget
	download_args=(-O "${outputpath}")
	download_args+=("${url}")
    else
	## use curl
	download_args=(--get)
	download_args+=(--silent)
	#download_args+=(--verbose)
	download_args+=(--show-error)
	download_args+=(--fail)
	download_args+=("${url}")
	download_args+=(-o "${outputpath}")
    fi
    res="$(${cmd_download} "${download_args[@]}" 2>&1 &)"
    if [[ $? -ne 0 ]]; then
	processchain="$(printf "%s<-" "${FUNCNAME[@]}")"
	printf "%s: %s error %s downloading font:\n%s\n" \
	       "${processchain}" "${cmd_download}" "${ret}" "${res}"
	return 3
    else
	printf "succesfully downloaded font file to '%s' in directory '%s'." \
	       "${filename}" "${checked_dir}"
    fi
}


function httpget_atrule_google() {
    ## Validates the chosen combination of font and language subset at
    ## google using curl or wget, and returns the resulting font-face
    ## atrule to the calling function, or, if the format ($5) is
    ## specified, retrieve the download url for the font.
    ## Exits with descriptive error when no success.
    ## In the second iteration ("${formatspec}x" != "x") the fonts'
    ## file format is specified, which will be used to mimic a certain
    ## user agent to get the proper FORMATSPEC.
    ## see https://developers.google.com/fonts/docs/technical_considerations#what_is_the_google_fonts_api_serving
    cmd_download="$1"
    fontname="$2"
    fontstyleweight="$3"
    local subsetspec="$4"
    local formatspec="${5:-x}" ## only used in the second iteration
    fontfamily="${fontname}:${fontstyleweight}"
    local download_args=()
    if [[ "${cmd_download}" == "${cmd_wget}" ]]; then
	## use wget
	download_args=(-O "-")
	## depend on wgets' builtin url-encoding
	str_postdata="family=${fontfamily}&subset=${subsetspec}"
	if [[ "${formatspec}x" != "x" ]]; then
	    download_args+=(--user-agent="'${useragent[${formatspec}]}'")
	fi
	## needed for making wget understand option arguments stop,
	## and url starts
	download_args+=(--)
	download_args+=("${GOOGLE_FONTAPI_URL}?${str_postdata}")
    else
	## use curl
	download_args=(--get)
	download_args+=(--silent)
	download_args+=(--show-error)
	download_args+=(--fail)
	## depend on curls' builtin url-encoding
	download_args+=(--data-urlencode "family=${fontfamily}")
	download_args+=(--data-urlencode "subset=${subsetspec}")
	if [[ "${formatspec}x" != "x" ]]; then
	    download_args+=(--user-agent "'${useragent[${formatspec}]}'")
	fi
	download_args+=("${GOOGLE_FONTAPI_URL}")
    fi
    cssattr_font_face="$(LANG=C ${cmd_download} "${download_args[@]}" 2>&1 &)"
    ret=$?
    if [[ ${ret} -ne 0 ]]; then
	processchain="$(printf "%s<-" "${FUNCNAME[@]}")"
	printf "%s: error %s using %s:\n%s\n" \
	       "${processchain}" "${ret}" "${cmd_download}" "${cssattr_font_face}"
	return 1
    else
	## return the complete font-face atrule
	printf "%s" "${cssattr_font_face}"
    fi
}


function validate_arg_formatspec() {
    ## validate the FORMATSPEC specified by the user in $1 against
    ## valid_formatspecs.
    ## returns error if no argument could be validated.
    ## convert comma separated arguments into array
    a_formatspecs=( ${1//,/ } )
    case "${a_formatspecs[@]}x" in 
	allx)
     	    ## argument is 'all'; add all available formats to array
	    a_checked_formatspecs=( ${valid_formatspecs[@]} )
	    ;;
	x|practicalx)
	    ## argument is empty or 'practical'
	    a_checked_formatspecs=( ${practical_formatspecs[@]} )
	    ;;
	*deeper*x)
	    a_checked_formatspecs=( ${slightlydeeper_formatspecs[@]} )
	    ;;
	*progressive*x)
	    a_checked_formatspecs=( ${superprogressive_formatspecs[@]} )
	    ;;
	*)
	    ## user specified FORMATSPECS, try to iterate the array
	    # shellcheck disable=SC2068
	    for formatspec in ${a_formatspecs[@]}; do
		if [[ "${formatspec}x" == "allx" ]]; then
		    a_checked_formatspecs+=( ${valid_formatspecs[@]} )
		    continue
		else
		    # shellcheck disable=SC2076
		    if [[ ${valid_formatspecs[@]} =~ "${formatspec}" ]]; then
			a_checked_formatspecs+=( "${formatspec}" )
		    else
			## invalid FORMATSPEC specified
			err_invalid_arg "arg_formatspecs" "${formatspec}"
		    fi
		fi
	    done
	    ;;
    esac
    if [[ ${#a_checked_formatspecs[@]} -eq 0 ]]; then
	## return error	
	return 1
    else
	## return the array as a space separated list
	printf "%s " "${a_checked_formatspecs[@]}"
    fi
}


function validate_arg_subsetspec() {
    ## validate the SUBSETSPEC specified by the user in $1
    ## against valid_subsetspecs.
    ## returns error if no choice could be validated.
    ## convert comma separated arguments into array
    a_subsetspecs=( ${1//,/ } )
    if [[ "${a_subsetspecs[@]}" =~ all ]]; then
	## when 'all' is chosen skip any other
	a_checked_subsetspecs+=( "all" )
    else
	# shellcheck disable=SC2068,SC2076
	for subsetspec in ${a_subsetspecs[@]}; do
	    if [[ ${valid_subsetspecs[@]} =~ "${subsetspec}" ]]; then   
		a_checked_subsetspecs+=("${subsetspec}")
	    else
		err_invalid_arg "arg_subsetspecs" "${subsetspec}"
	    fi
	done
    fi
    ## return error
    if [[ ${#a_checked_subsetspecs[@]} -eq 0 ]]; then
	return 1
    else
	## return space separated string with valid SUBSETSPECS
	printf "%s " "${a_checked_subsetspecs[@]}"
    fi
}


function process_atrule() {
    ## process the supplied fontface atrule ($1), by extracting all
    ## its attributes, adding the font file name and url for each
    ## FORMATSPEC/SUBSETSPEC to the a_downloads array, and storing the
    ## resulting css in the temporary variable 'temp_atrule'.
    cssattr_font_face="$1"
    cssattr_font_family=""
    cssattr_font_weight=""
    cssattr_font_style=""
    cssattr_src=""	
    cssattr_src_local_nonps=
    cssattr_src_local_ps=
    cssattr_src_url=
    ## initialize for later use
    download_url=
    font_version=""
    a_url_format_attrs=()
    ## setup regular expressions to match css attributes and to
    ## determine their values
    re_font_family="font-family:[[:space:]]*'(.*)';"
    re_font_weight="font-weight:[[:space:]]*(.*);"
    re_font_style="font-style:[[:space:]]*(.*);"
    re_src="src:[[:space:]]*(.*);"
    re_src_local="local\([']?(.*)[']?\)"
    ## matches only the url value 'url(...)' not the optional trailing
    ## 'format(...)'
    re_src_url="url\(([^[:space:]]*)\)"
    re_src_url_version="/(v[0-9]*)/"
    ## process the (newline separated) font-face atrule
    while read -r line; do
	if [[ "${line}" =~ ${re_font_family} ]]; then
	    ## font-family attribute
	    cssattr_font_family="${BASH_REMATCH[1]}"
	elif [[ "${line}" =~ ${re_font_weight} ]]; then
	    ## font-weight attribute
	    cssattr_font_weight="${BASH_REMATCH[1]}"
	elif [[ "${line}" =~ ${re_font_style} ]]; then
	    ## font-style attribute
	    cssattr_font_style="${BASH_REMATCH[1]}"
	elif [[ "${line}" =~ ${re_src} ]]; then
	    ## src attribute
	    cssattr_src="${BASH_REMATCH[1]}"	
	fi
    done<<<"${cssattr_font_face}"
    ## parse the src attribute to extract the 'local' font family
    ## values for both the non-PS and PS family name, and the
    ## 'url(...) format(...)' values for the version of the font
    # shellcheck disable=SC2162
    while IFS=, read local_nonps local_ps url_format; do
	[[ "${local_nonps}" =~ ${re_src_local}  ]] &&
	    cssattr_src_local_nonps="${BASH_REMATCH[1]}"
	[[ "${local_ps}" =~ ${re_src_local} ]] && \
	    cssattr_src_local_ps="${BASH_REMATCH[1]}"
	[[ "${url_format}" =~ ${re_src_url} ]] && \
	    cssattr_src_url="${BASH_REMATCH[1]}"
    done<<<"${cssattr_src}"
    ## remove single quotes if any
    cssattr_src_local_nonps="${cssattr_src_local_nonps//\'/}"
    cssattr_src_local_ps="${cssattr_src_local_ps//\'/}"
    ## create a label for saving and referencing the font file
    if [[ "${cssattr_src_local_nonps}x" == "x" ]]; then
	## local attribute not set; use the font family
	base_localname="${cssattr_font_family}"
    else
	## use the escaped local (non PS) attribute
	base_localname="${cssattr_src_local_nonps}"
    fi
    base_localname="${base_localname// /_}"
    ## try to get the version from the url, otherwise leave empty
    if [[ "${cssattr_src_url}" =~ ${re_src_url_version} ]]; then
	font_version="${BASH_REMATCH[1]}_"
    fi
    ## process each FORMATSPEC/SUBSETSPEC
    # shellcheck disable=SC2068
    for formatspec in ${a_checked_formatspecs[@]}; do
	# shellcheck disable=SC2068
	for subsetspec in ${a_checked_subsetspecs[@]}; do
	    add_eot_src_attr=
	    cssattr_font_face="$(httpget_atrule_google \
	    "${cmd_download}" \
	    "${cssattr_font_family}" \
	    "${cssattr_font_weight}${cssattr_font_style}" \
	    "${subsetspec}" \
	    "${formatspec}")"
	    ## determine and set the filename's extension, suffix
	    ## (part after the extension) and other quirk workarounds
	    suffix=
	    label_format="${formatspec}"
	    extension="${formatspec}"
	    case ${formatspec} in
		ttf|truetype)
		    ## replace 'ttf' with 'truetype' if applicable
		    label_format="truetype"
		    extension="ttf"
		    ;;
		svg*)
		    ## agents capable of using svg(z) fonts, gather the
		    ## font family from the suffix after the extension
		    ## and a hash sign with spaces removed, eg.
		    ## 'fontfile.ext#FontFamily'.
		    suffix="#${cssattr_font_family// /}"
		    ;;
		eot*|embedded-opentype)
		    ## 'fontfile.ext?iefix'.
		    label_format="embedded-opentype"
		    suffix="?iefix"
		    add_eot_src_attr=True
		    ;;
		otf*|opentype)
		    ## 'fontfile.ext?iefix'.
		    label_format="opentype"
		    ;;		
	    esac

	    ## construct the filename
	    filename="${base_localname}_${font_version}${subsetspec}_${cssattr_font_weight}.${extension}"
   
	    url_format_template="        url('%s') format('%s'),\n"
	    if [[ "${add_eot_src_attr}x" != "x" ]] && [[ "${formatspec}" = "eot" ]]; then
		## prepend the final src variable with the ie9 quirk workaround
		eot_src_attr="src: url('${filename}');\n"
	    fi
	    if [[ "${arg_incss_fontsdir}x" = "x" ]]; then
		# shellcheck disable=SC2059
		a_url_format_attrs+=("$(printf "${url_format_template}" \
"${filename}${suffix}" "${label_format}")")
	    else
		## prefix the filename with the incss font path; if the
		## user specified a path with a trailing slash, remove
		## it
		# shellcheck disable=SC2059
		a_url_format_attrs+=("$(printf "${url_format_template}" \
"${arg_incss_fontsdir%/}/${filename}${suffix}" "${label_format}")")
	    fi
	    if [[ "${arg_skipdownload}x" == "x" ]]; then
		## download the web font(s)
		## get the url for this FORMATSPEC/SUBSETSPEC
    		if [[ "${cssattr_font_face}" =~ ${re_src_url} ]]; then
		    download_url="${BASH_REMATCH[1]}"
		else
		    printf 1>&2 "BUG: can't extract url from src attribute=\n###\n%s\n###\n" \
				"${cssattr_font_face}"
		    ## try the next subsetspec
		    continue
		fi
		## add an array item
		a_downloads[${filename}]="${download_url}"
	    fi
	done 
    done
    ## convert array to multi-lined string
    cssattr_src_urlformats="$(printf "%s\n" "${a_url_format_attrs[@]}")"
    ## replace last comma with semi-colon
    cssattr_src_urlformats="${cssattr_src_urlformats%?};"
    ## generate the atrule and add it to the temp variable
    res=$(generate_css \
	      "${cssattr_font_family}" \
	      "${cssattr_font_style}" \
	      "${cssattr_font_weight}" \
	      "${cssattr_src_local_nonps}" \
	      "${cssattr_src_local_ps}" \
	      "${cssattr_src_urlformats}" \
	      "${eot_src_attr}")
    temp_atrule="$(printf "%s\n" "${res}")"
}


function create_atrules() {
    ## process each item in the fontspecs array, create the proper css
    ## atrule for it and store it in the a_atrules_created array.
    ## setup basic regexp matching
    family_re="(.*):(.*)"
    for family in "${a_arg_fontspecs[@]}"; do
	if [[ "${family}" =~ ${family_re} ]]; then
	    fontname="${BASH_REMATCH[1]}"
	    ## construct array from second match, by replacing commas
	    ## (if any) by spaces to get the requested font styles
	    styles=( ${BASH_REMATCH[2]//,/ } )
	else
	    ## font spec without style; append 'regular'
	    fontname="${family}"
	    styles=( regular )
	fi
	## iterate the array and process each name/style pair
	for fontstyle in "${styles[@]}"; do
	    ## check the validity of the specified name/value pair
            ## (eg. 'Font_Name:weightx,weighty') and get and return it's
	    ## font-face atrule
	    atrule="$(httpget_atrule_google \
"${cmd_download}" \
"${fontname//\'/}" \
"${fontstyle//\'/}" \
"${a_checked_subsetspecs[@]}")"
	    if [[ $? -ne 0 ]]; then
		## add the invalid specification to the array
		a_invalid_specs+=("- '${fontname}:${fontstyle}'" )
	    else
		## process the fontface atrule for the chosen fontname:fontstyle
		## the result is stored in temp_atrule
		temp_atrule=""
		process_atrule "${atrule}"
		if [[ $? -ne 0 ]]; then
		    printf 1>&2 "BUG: error processing atrule:\n%s\nerror was:\n''\n" \
			   "${atrule}" "${res}"
		    return 1
		else
		    ## add the atrule for this fontspec to the array
		    a_atrules_created+=("$(printf "%s\n" "${temp_atrule}")")
		fi
	    fi
	done
    done
    
}

## path to css file
arg_output_cssfile="${arg_output_cssfile:-}"
## font download directory
arg_fonts_dir="${arg_fonts_dir:-}"
## commandline argument -s/--skip-download
arg_skipdownload="${arg_skipdownload:-}"
## commandline argument -x/--skip-local-src-attr
arg_skiplocal="${arg_skiplocal:-}"
## comma separated list of font subsets to be downloaded, defaults to latin
arg_subsetspecs="${arg_subsetspecs:-${DEF_ARG_SUBSETSPECS}}"
## comma separated list of font formats to be downloaded
## defaults to 'practical' (eg 'woff & woff2')
arg_formatspecs="${arg_formatspecs:-${DEF_ARG_FORMATSPECS}}"
arg_overwrite_css="${arg_overwrite_css:-}"
arg_overwrite_fonts="${arg_overwrite_fonts:-}"

## initialize arrays for storing validated selections
## array to hold the commandline font specification(s)
declare -a a_arg_fontspecs
declare -A a_downloads
declare -a a_checked_formatspecs
declare -a a_checked_subsetspecs
declare -a a_atrules_created
declare -a a_warnings
declare -a a_msg_err
declare checked_dir


## valid choices
valid_subsetspecs=(cyrillic cyrillic-ext greek greek-ext latin latin-ext vietnamese all)
valid_formatspecs=(eot otf woff woff2 svg ttf)
## supersets of font formats, taken from:
## https://css-tricks.com/snippets/css/using-font-face/
superprogressive_formatspecs=("woff2")
practical_formatspecs=( ${superprogressive_formatspecs[@]} "woff")    
slightlydeeper_formatspecs=( ${practical_formatspecs[@]} "ttf" )

## use a specific user agent in HTTP requests to Googles font site to get the correct css.
## see: http://www.useragentstring.com/
declare -A useragent="(\
[eot]='Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0)'
[woff]='Mozilla/5.0 (Windows NT 6.1; WOW64; rv:27.0) Gecko/20100101 Firefox/27.0'
[woff2]='Mozilla/5.0 (Windows NT 6.1; WOW64; rv:40.0) Gecko/20100101 Firefox/40.0'
[svg]='Mozilla/4.0 (iPad; CPU OS 4_0_1 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko) Version/4.1 Mobile/9A405 Safari/7534.48.3'
[ttf]='Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.54.16 (KHTML, like Gecko) Version/5.1.4 Safari/534.54.16'
[otf]='Mozilla/5.0 (Windows; U; MSIE 9.0; WIndows NT 9.0; en-US))'\
)"
# shellcheck disable=SC2154
declare -A useragent[svgz]="${useragent[svg]}"

goggle_url_re="['http's]?[s:]?//${GOOGLE_FONTAPI_HOST//./\\\.}/css\?family="
## matching group contains everything upon the next space
goggle_html_link_re="['<link href=\"']?${goggle_url_re}([^[:space:]]*)"
## matching group contains everything upon the next ')'
goggle_js_import_re="['@import url\(']?${goggle_url_re}']?([^\)*)[;]?"

a_invalid_specs=()
a_fonts_exists=()
nr_downloadfonts=0

label_overwrite_all="--overwrite"
label_overwrite_css="--overwrite-css"
label_overwrite_fonts="--overwrite-fonts"
label_skip_localsrc="--skip-local"
if [[ "${0}" =~ /dev/fd.* ]]; then
    ## script loaded from stdin
    label_appname="${APP_NAME}"
else
    label_appname="${0:-APP_NAME}"
fi
cmdline_args_raw="$(printf "%s " "$@" | fmt)"
cmdline_args="$(while read -r line; 
do printf "%s \ \n" "${line}"; 
done< <(printf "%s \n" "${cmdline_args_raw}"))"
## strip last line continuation mark
cmdline_args="${cmdline_args%%\\ }"
css_header="/* font-face at-rules generated with ${label_appname} (version ${APP_VERSION})
   using command:
${label_appname} \ "
css_header+="
${cmdline_args}
>>> font-face at-rules start here >>> */"
#css_header="$(printf "%s\n" "${raw_css_header}" | fmt --prefix="/*")"
css_footer="/* <<< generated font-face at-rules end here <<< */"

## main program flow

## analyze and store all commandline arguments
analyze_commandline_args "$@" || exit 1
## turn FONTSPECs in arg_fontspecs set by analyze_commandline_args
## into an array
# shellcheck disable=SC2162
while read fontspec; do
    if [[ "${fontspec}x" != "x" ]]; then
	a_arg_fontspecs+=( "${fontspec}" )
    fi
done<<<"${arg_fontspecs}"
if [[ ${#a_arg_fontspecs[@]} -eq 0 ]]; then
    err_exit "Error: not a single valid FONTSPEC found."
fi
## check user specified FORMATSPEC (applicable for all fontspecs)
a_checked_formatspecs=( $(validate_arg_formatspec "${arg_formatspecs}") )
if [[ $? -ne 0 ]]; then
    err_exit "Error: supplied FORMATSPEC (\`${arg_formatspecs}') is invalid."
fi
## check commandline SUBSETSPEC (applicable for all fontspecs)
a_checked_subsetspecs=( $(validate_arg_subsetspec "${arg_subsetspecs}") )
if [[ $? -ne 0 ]]; then
    err_exit "Error: no valid SUBSETSPEC supplied."
fi
## check which downloader should be used (for checking FONTSPECS and
## downloading fonts).
cmd_download=
cmd_curl=$(type -p curl)
if [[ $? -ne 0 ]]; then
    ## curl is not installed, try wget
    cmd_wget=$(type -p wget)
    if [[ $? -ne 0 ]]; then
        err_exit "Error: no valid download command found (tried \`curl' and \`wget')."
    else
	## use wget
	cmd_download="${cmd_wget}"
    fi
else
    ## use curl
    cmd_download="${cmd_curl}"
fi
## check the output directory (arg_fonts_dir) if applicable
checked_dir="$(get_fontsdirectory)"
if [[ $? -ne 0 ]]; then
    ## return value contains error message, display it
    printf 1>&2 "%s\n" "${checked_dir}"
    exit 1
fi

## for each verified FONTSPEC create a valid atrule stored in a_atrules
create_atrules
ret=$?
if [[ ${ret} -ne 0 ]]; then
    msg="ANOMALITY:
\`create_atrules' returned error \`${ret}'. This should not happen.
Please check the output of the script above and include that if you
decide to file a bug at ${APP_GITHUBURL}."
    err_exit "${msg}"
fi

## check if warnings were produced by create-atrules
## TODO: turn decision about fatality of FONTSPEC errors into a user
## choice (extra commandline argument)
if [[ ${#a_invalid_specs[@]} -gt 0 ]]; then
    ## invalid (or unparsable) FONTSPEC
    a_msg_err+=("Could not process the following font specifications:")
    a_msg_err+=("$(printf " %s\n" "${a_invalid_specs[@]}")")
fi
## check if valid atrules were created; if not exit with error
if [[ ${#a_atrules_created[@]} -le 0 ]]; then
    msg="Error: not a single FONTSPEC could be validated using
       ${GOOGLE_FONTAPI_URL}.

Please compare your FONTSPEC argument (\`${arg_fontspecs}') against
the ones supplied by ${GOOGLE_FONTS_URL} and try again.
"
    err_exit "${msg}"
fi

## check if a css output file is specified, if so if it exists,
## and whether it should be overwritten
if [[ "${arg_output_cssfile}x" == "x" ]]; then
    ## no css output file specified
    arg_output_cssfile=/dev/stdout
else
    ## css output file specified
    if [[ -f "${arg_output_cssfile}" ]] && \
	   [[ "${arg_overwrite_css}x" == "x" ]]; then
	## css output file already exists and should not be overwritten
	msg="- not overwriting existing css file \`${arg_output_cssfile}' \
(tip: use \`${label_overwrite_css}')."
	a_msg_err+=("${msg}" )
	arg_output_cssfile=/dev/stdout
    else
	## css output file does not exist, check the target directory
	cssdir="$(dirname "${arg_output_cssfile}")"
	if [[ -d "${cssdir}" ]]; then
	    ## exisiting target directory
	    if [[ ! -w "${cssdir}" ]]; then
		a_msg_err+=("- directory \`${cssdir}' is not writable.")
		arg_output_cssfile=/dev/stdout
	    fi
	else
	    ## non-exisiting target directory, create it
	    res="$(mkdir -p "${cssdir}" 2>&1)"
	    if [[ $? -ne 0 ]]; then
		a_msg_err+=("- can create directory \`${cssdir}'.")
		arg_output_cssfile=/dev/stdout			
	    fi
	fi 
    fi
fi

## valid FONTSPEC(s) found, start writing css output
## TODO: turn decision about fatality of download errors into a user
## choice (extra commandline argument)
## TODO: supply command line argument to skip header/footer
printf "%s\n" "${css_header}" > "${arg_output_cssfile}"
for atrule in "${a_atrules_created[@]}"; do 
    printf "%s\n" "${atrule}" >> "${arg_output_cssfile}"
done 
printf "%s\n" "${css_footer}" >> "${arg_output_cssfile}"
## download the font files if applicable
if [[ "${arg_skipdownload}x" != "x" ]]; then
    a_msg_err+=("skipping downloading of font files as requested.")
else
    printf 1>&2 "Downloading font files " 
    for filename in "${!a_downloads[@]}"; do
	res="$(download_fontfile "${cmd_download}" \
 "${a_downloads[${filename}]}" "${filename}")"
	## consider failed download non-fatal (see TODO above)
	case $? in
	    0) printf 1>&2 "." ;;
	    1) a_fonts_exists+=("- not overwriting \`${res}'") ;; 
	    2) a_msg_err+=("$(printf 1>&2 "%s\n" "${res}")") ;;
	    3) a_msg_err+=("error downloading font file: ${res}") ;;		    
	esac
    done
    if [[ ${#a_fonts_exists[@]} -gt 0 ]]; then 
	nr_downloadfonts=$(( ${#a_downloads[@]} - ${#a_fonts_exists[@]} ))
	printf 1>&2 " ... %s done (%s not overwritten).\n" \
		    "${nr_downloadfonts}" "${#a_fonts_exists[@]}"
    else 
	printf 1>&2 "%s done.\n" "${#a_downloads[@]}"
    fi
    printf 1>&2 "* fonts available in: \`%s'\n" "${checked_dir}"
fi
## display errors/warnings if applicable
if [[ ${#a_msg_err[@]} -gt 0 ]]; then
    printf 1>&2 "\nPlease note the following:\n"
    printf 1>&2 "%s\n" "${a_msg_err[@]}"
else
    if [[ "${arg_output_cssfile}" != "/dev/stdout" ]]; then
	printf 1>&2 "* css file saved in:  \`%s'\n" "${arg_output_cssfile}"
    fi
fi

## all done
