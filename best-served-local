#!/usr/bin/env bash

## `best-served-local' is a bash script that helps serving (Google)
## web fonts from your own server, by creating valid css font-face
## atrules and/or downloading the font files.
##
##  Copyright Â© 2016 Ronald van Engelen <ronalde+github@lacocina.nl>
##  This program is free software: you can redistribute it and/or modify
##  it under the terms of the GNU General Public License as published by
##  the Free Software Foundation, either version 3 of the License, or
##  (at your option) any later version.
##
##  This program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##  GNU General Public License for more details.
##
##  You should have received a copy of the GNU General Public License
##  along with this program.  If not, see <http://www.gnu.org/licenses/>.
##
## The script, helpers and documentation are published at 
## https://lacocina.nl/using-best-served-local
##
## Inspired by https://github.com/neverpanic/google-font-download.git and
## https://github.com/neverpanic/google-font-download.git
## 
## Also see `README.md'

## constants and defaults
## font SUBSETSPECS to be downloaded, defaults to 'latin'
## see https://developers.google.com/fonts/docs/getting_started#specifying_script_subsets
DEF_ARG_SUBSETSPECS="latin"
## comma separated list of FORMATSPECS to be downloaded
## defaults to 'practical' (eg 'woff & woff2')
DEF_ARG_FORMATSPECS="practical"
## app defaults
APP_NAME="best-served-local"
APP_VERSION="0.7.1"
APP_URL="https://lacocina.nl/using-${APP_NAME}"
APP_GITHUBURL="https://github.com/ronalde/best-served-local"
## google constants
GOOGLE_FONTAPI_HOST="fonts.googleapis.com"
GOOGLE_FONTAPI_URL="https://${GOOGLE_FONTAPI_HOST}/css"
GOOGLE_FONTS_URL="https://fonts.google.com/"

cmd_download="${cmd_download:-}"

function err_exit() {
    ## display fatal error triggered by function $1 with description
    ## $2 and exit with error
    printf 1>&2 "%s\n" "$1"
    printf 1>&2 "Run \`%s -h' to see usage information.\n" \
		"${APP_NAME}"
    exit 1
}

function get_download_cmd() {

    case "${cmd_download}" in
	*curl)
	    cmd_curl=$(type -p curl) || \
		err_exit "user specified download command (\`${cmd_download}') not found." 
	    cmd_download="${cmd_curl}"
	    ;;
	*wget)
	    cmd_wget=$(type -p wget) ||  \
		err_exit "user specified download command (\`${cmd_download}') not found."
	    cmd_download="${cmd_wget}"
	    ;;
	*)
	    ## not supplied as an environment variable
	    cmd_curl=$(type -p curl)
	    if [[ $? -ne 0 ]]; then
		## curl is not installed, try wget
		cmd_wget=$(type -p wget)
		if [[ $? -ne 0 ]]; then
		    err_exit "Error: no valid download command found (tried \`curl' and \`wget')."
		else
		    ## use wget
		    cmd_download="${cmd_wget}"
		fi
	    else
		## use curl
		cmd_download="${cmd_curl}"
	    fi
	    ;;
    esac
}

function rawurlencode() {
    ## Source:
    ## http://stackoverflow.com/questions/296536/how-to-urlencode-data-for-curl-command
    local string="${1}"
    local strlen=${#string}
    local encoded=""
    local pos c o
    for (( pos=0 ; pos<strlen ; pos++ )); do
	c=${string:$pos:1}
	case "$c" in
            [-_.~a-zA-Z0-9])
		o="${c}"
		;;
            *)
		printf -v o '%%%02x' "'$c"
	esac
	encoded+="${o}"
    done
    printf "%s" "${encoded}"
}

function get_fontsdirectory() {
    ## check the user specified directory for storing the fontfiles in
    ## arg_fonts_dir and create it if neccessary, or create a
    ## temporary directory.
    ## returns the path to the directory, or an error with description.
    declare -a a_msg_err
    msg=
    if [[ "${arg_fonts_dir}x" == "x" ]]; then
	## no font directory specified, create a temporary one
	arg_fonts_dir="$(mktemp -dt ${APP_NAME}.XXXX)"
	if [[ $? -ne 0 ]]; then
	    a_msg_err+=("- could not create a temporary font directory.")
	fi
    else
	## font directory specified, check if it is exists
	if [[ ! -d "${arg_fonts_dir}" ]]; then
	    ## it doesn't, create it
	    res="$(mkdir -pv "${arg_fonts_dir}" 2>&1)"
	    if [[ $? -ne 0 ]]; then
		msg="- unable to create font directory '${arg_fonts_dir}'; "
		msg+="\`mkdir' returned: '${res}'"
		a_msg_err+=("${msg}")
	    fi
	else
	    ## it does, check if it's writable
	    if [[ ! -w "${arg_fonts_dir}" ]]; then
		a_msg_err+=("- specified directory '${arg_fonts_dir}' is not writable.")
	    fi
	fi
    fi
    if [[ ${#a_msg_err[@]} -gt 0 ]]; then
	printf "The following error(s) occured:\n%s\n" "${a_msg_err[@]}"
	return 1
    else 
	## no errors; return the path of the directory
	printf "%s" "${arg_fonts_dir}"
    fi
}

function display_usageinfo() {
    msg="Usage:
   ${APP_NAME} [-o|--outputfile PATH] [-d|--fontdirectory PATH] \\
        [-i|--incss-fontpath PATH] \\
        [-s|--subsetspec SUBSETSPEC] [-f|--formats FORMATSPEC] \\
        [-n|--skip-downloads] [-x|${label_skip_localsrc}] \\
        [${label_overwrite_css}] [${label_overwrite_fonts}] \\
        [${label_overwrite_all}] [${label_includechrome}] \\
        [-h|--help] \\
        FONTSPEC

  OPTIONAL ARGUMENTS
  -o|--outputfile PATH     Path to the file to save the CSS in.
  -d|--fontdirectory PATH  Path to the directory to download fonts to.
  -i|--incss-fontpath PATH Path used to reference font files within the css.
  -n|--no-downloads        Prevents the script from downloading web fonts.
  -x|${label_skip_localsrc}          Prevents the inclusion of the 'local()' values.
  -f|--formatspecs FORMATSPECS Comma-separated list of FORMATSPECS.
  -s|--subsetspecs SUBSETSPECS Comma-separated list of SUBSETS.
  ${label_overwrite_css}          Overwrite existing css file.
  ${label_overwrite_fonts}        Overwrite existing font files.
  ${label_overwrite_all}              Overwrite existing font and css files.
  ${label_includechrome}         Surround generated css with header and footer
  -h|--help                Show this help message and exit.

  With default settings, a CSS Level 3 @font-face atrule is printed to
  stdout and the font files are downloads to a temporary
  directory. Errors and warnings are printed to stderr, so it should
  be save to redirect the output, which always is css.

  FONTSPEC should be space separated list of family names, with
  optional suffix consisting of \`:' with a comma separated list of
  font weight/style values. For example to use \"Open Sans\" in the
  regular font weight and style with the latin subset in the formats
  \`woff' and \`woff2' use:
      ${APP_NAME} \"Open Sans\"

  FORMATSPECS should be one of the following presets, taken
  from https://css-tricks.com/snippets/css/using-font-face/:
  - \`superprogressive': \`woff2'
  - \`practical':        superprogressive + \`woff'
  - \`slightlydeeper':   practical + \`ttf'
  - \`all':              all of the above + \`odt' and \`svg'.

  For extensive documentation and usage examples, see:
  ${APP_URL}

  ${APP_NAME} Copyright (C) 2016 Ronald van Engelen (See LICENSE).
"
    printf 1>&2 "%s\n" "${msg}"
    exit
}


function err_invalid_arg() {
    ## inform user about an invalid value ($2) for commandline argument ($1)
    argument="$1"
    value="$2"
    ## construct string containing valid values for specified argument
    msg_valid="$(msg_valid_argumentvalues "${argument#-*}")"
    a_warnings=("Error: invalid argument specified:")
    case "${value}x" in
	"x")
	    a_warnings+=("- empty value for argument '${argument}' specified.")
	    ;;
	"0x")
	    ## special case, return the string to calling function
	    a_warnings+=("- none of the specified value(s) for argument '${argument}' are valid.")
	    ;;
	*)
	    a_warnings+=("- invalid value '${value}' for argument '${argument}' specified.")
	    ;;
    esac
    a_warnings+=("${msg_valid}")
    msg_error="$(printf "%s\n" "${a_warnings[@]}")"
    err_exit "${msg_error}"
}


function msg_valid_argumentvalues() {
    ## construct and return string with valid values for commandline argument $1
    argument="$1"
    case ${argument#-*} in
	f|format|arg_formatspecs)
	    printf "\tMust be 'superprogressive', 'practical',
	    'slightlydeeper' or 'all', or one or more of "
	    values="$(printf "%s," "${valid_formatspecs[@]}")"
	    printf "%s\n" "${values%*,}"
	    ;;
	l|subsets|arg_subsetspecs)
	    printf "\tMust be 'all' or one or more of: "
	    values="$(printf "%s," "${valid_subsetspecs[@]}")"
	    printf "%s\n" "${values%*,}"
	    ;;
	i|incss-fontpath)
	    printf "  should be a string.\n"
	    ;;
    esac
}


function analyze_commandline_args() {
    ## parse command line arguments using the `manual loop` method
    ## described in http://mywiki.wooledge.org/BashFAQ/035.
    while :; do
        case "${1:-}" in
            -o|--outputfile)
		if [[ -n "${2:-}" ]]; then
		    arg_output_cssfile="${2}"
		    shift 2
                    continue
		else
		    err_invalid_arg "$1" "$2"		    
                    return 1
		fi
		;;
            -d|--fontdirectory)
		if [[ -n "${2:-}" ]]; then
		    arg_fonts_dir="${2}"
		    shift 2
                    continue
		else
		    err_invalid_arg "$1" "$2"		    
		    return 1
		fi
		;;
            -i|--incss-fontpath)
		if [[ -n "${2:-}" ]]; then
		    arg_incss_fontsdir="${2}"
		    if [[ "${arg_incss_fontsdir:0:1}" == '-' ]]; then
			err_invalid_arg "$1" "$2"
			return 1
		    fi
		    shift 2
                    continue
		else
		    err_invalid_arg "$1" "$2"		    
		    return 1
		fi
		;;
	    -s|--subsets*|-l)
		## -l for compatibility with google-font-download from neverpanic
		if [[ -n "${2:-}" ]]; then
		    arg_subsetspecs="${2}"
		    shift 2
                    continue
		else
		    err_invalid_arg "$1" "$2"
		    return 1
		fi
		;;
	    -f|--formats*)
		if [[ -n "${2:-}" ]]; then
		    arg_formatspecs="${2}"
		    shift 2
                    continue
		else
		    err_invalid_arg "$1" "$2"		    		    
		    return 1
		fi
		;;
	    -n|--no-downloads)
		if [[ -n "${2:-}" ]]; then
		    arg_skipdownload=True
		    shift
		    continue
		fi
		;;
	    -x|"${label_skip_localsrc}"*)
		if [[ -n "${2:-}" ]]; then
		    arg_skiplocal=True
		    shift
		    continue
		fi
		;;
	   "${label_overwrite_css}"*)
		if [[ -n "${2:-}" ]]; then
		    arg_overwrite_css=True
		    shift
		    continue
		fi
		;;
	    "${label_overwrite_fonts}"*)
		if [[ -n "${2:-}" ]]; then
		    arg_overwrite_fonts=True
		    shift
		    continue
		fi
		;;
	    "${label_overwrite_all}")
		if [[ -n "${2:-}" ]]; then
		    arg_overwrite_fonts=True
		    arg_overwrite_css=True
		    shift
		    continue
		fi
		;;
	    "${label_includechrome}")
		if [[ -n "${2:-}" ]]; then
		    arg_includechrome=True
		    shift
		    continue
		fi
		;;
	    -h|-\?|--help) 
		display_usageinfo
		exit
		;;
            --)
		## comma separated list of fonts (eg
		## 'font:weight(slant) font2:weight(slant)')
		shift
		break
		;;
	   -?*)
	       printf 1>&2 "Notice: unknown option \`%s' ignored\n\n" "$1"
               display_usageinfo
	       exit
               ;;
           *)
               break
        esac
    done
    ## shift the options index to get the remainder of the command
    ## line arguments containing the font descriptions
    ## and return them as 0-separated strings.
    shift $((OPTIND - 1))
    arg_fontspecs="$(printf "%s\n" "$@")"
    if [[ "${arg_fontspecs}x" == "x" ]]; then 
	err_exit "Error: not a single FONTSPEC specified."
    fi
    pipes_in_arg=0
    pipes_in_arg=${arg_fontspecs//[^|]}
    if [[ ${#pipes_in_arg} -gt 0 ]] || \
	   [[ "${arg_fontspecs}" =~ ${goggle_html_link_re} ]] || \
	   [[ "${arg_fontspecs}" =~ ${goggle_js_import_re} ]]       ; then
	## fontspec contains at least a pipe symbol: it probably is the value of the href-attribute of
	## an html link-element, eg. 'WebfontA:100|WebfontB:italic')
	if [[ "${arg_fontspecs}" =~ ${goggle_html_link_re} ]] \
	       || [[ "${arg_fontspecs}" =~ ${goggle_js_import_re} ]]; then
	    ## the FONTSPEC contains the Google font url; strip it
	    re_match="${BASH_REMATCH[1]}"
	    ## convert any plus sign to space
	    re_match="${re_match//+/ }"
	    arg_fontspecs="$(htmlcsslink_to_fontspeclist "${re_match}")"
	else
	    arg_fontspecs="$(htmlcsslink_to_fontspeclist "${arg_fontspecs}")"
	fi
    fi 
}

function htmlcsslink_to_fontspeclist() {
    ## convert the href-attribute of an html link-element ($1) to a
    ## FONTSPEC list and return it to the calling function.
    fontspecs="${1:-}"
    fontspecs="${fontspecs//|/;}"
    IFS=\;
    for fontspec in ${fontspecs}; do 
	printf "%s\n" "${fontspec}"
    done
}


function generate_css() {
    ## return a complete font-face css rule
    cssattr_font_family="$1"
    cssattr_font_style="$2"
    cssattr_font_weight="$3"
    cssattr_src_local_nonps="$4"
    cssattr_src_local_ps="$5"
    cssattr_src_urlformats="$6"
    eot_src_attr="${7}"
    ## start the output template
    font_face_template="\
@font-face {
   font-family: '%s';
"
    ## check if the special ie9 quirk workaround should be applied
    if [[ "${eot_src_attr}x" != "x" ]]; then
	font_face_template+="$(printf "   %s\n" "${eot_src_attr}")"
    fi
    ## construct array to hold complete src attribute
    a_src_attrs=()
    ## check if the local property/properties should be set
    if [[ "${arg_skiplocal}x" == "x" ]]; then
	## skip 'local' argument not set
	if [[ "${cssattr_src_local_nonps}x" != "x" ]]; then
	    ## add 'local' non-postscript font name
	    src_local_attrs+=("local('${cssattr_src_local_nonps}')")
	fi 
	if [[ "${cssattr_src_local_ps}x" != "x" ]]; then
	    ## add 'local' postscript name
	    src_local_attrs+=("local('${cssattr_src_local_ps}')")
	fi
	if [[ ${#src_local_attrs[@]} -gt 0 ]]; then
	    ## convert array into comma separated string
	    src_local_line="$(printf "%s, " "${src_local_attrs[@]}")"
	    ## add each of the 'local' properties to the template
	    #font_face_template+="${src_local_line}"
	    ## add it it to array
	    a_src_attrs=("${src_local_line}")
	fi 
    fi
    ## append the 'url() format()' lines
    while read -r line; do
	a_src_attrs+=("${line}");
    done<<<"${cssattr_src_urlformats}"
    font_face_template+="   src:         ${a_src_attrs[0]}\n"
    font_face_template+="$(printf "                %s\n" "${a_src_attrs[@]:1}")"
    ## add the rest of the template (spaces are important for final formatting)
    font_face_template+="
   font-style:  %s;
   font-weight: %s;"
    ## return the complete filled-in css template to the calling
    ## function
    # shellcheck disable=SC2059
    printf "${font_face_template}" \
   "${cssattr_font_family}" \
   "${cssattr_font_style}" \
   "${cssattr_font_weight}
}"
}


function download_fontfile() {
    ## download the font file using $1 from url $2, save it locally in
    ## directory ${checked_dir} with filename $3.
    cmd_download="$1"
    url="$2"
    filename="$3"
    local download_args=()
    ## construct the full path
    local outputpath="${checked_dir}/${filename}"
    ## see if an existing font file should be overwritten
    if [[ -f "${outputpath}" ]] && [[ "${arg_overwrite_fonts}x" == "x" ]]; then
	## return the filename and a specific error
	printf "%s" "${outputpath}"
	return 1
    fi
    if [[ "${cmd_download}" == "${cmd_wget}" ]]; then
	## use wget
	download_args=(-O "${outputpath}")
	download_args+=("${url}")
    else
	## use curl
	download_args=(--get)
	download_args+=(--silent)
	#download_args+=(--verbose)
	download_args+=(--show-error)
	download_args+=(--fail)
	download_args+=("${url}")
	download_args+=(-o "${outputpath}")
    fi
    res="$(${cmd_download} "${download_args[@]}" 2>&1 &)"
    if [[ $? -ne 0 ]]; then
	processchain="$(printf "%s<-" "${FUNCNAME[@]}")"
	printf "%s: %s error %s downloading font:\n%s\n" \
	       "${processchain}" "${cmd_download}" "${ret}" "${res}"
	return 3
    else
	printf "succesfully downloaded font file to '%s' in directory '%s'." \
	       "${filename}" "${checked_dir}"
    fi
}


function httpget_atrule_google() {
    ## Validates the chosen combination of font and language subset at
    ## google using curl or wget, and returns the resulting font-face
    ## atrule to the calling function, or, if the format ($5) is
    ## specified, retrieve the download url for the font.
    ## Exits with descriptive error when no success.
    ## In the second iteration ("${formatspec}x" != "x") the fonts'
    ## file format is specified, which will be used to mimic a certain
    ## user agent to get the proper FORMATSPEC.
    ## see https://developers.google.com/fonts/docs/technical_considerations#what_is_the_google_fonts_api_serving
    cmd_download="$1"
    fontname="$2"
    fontstyleweight="$3"
    local subsetspec="$4"
    local formatspec="${5:-}" ## only used in the second iteration
    fontfamily="${fontname}:${fontstyleweight}"
    unset download_args
    local download_args=()
    if [[ "${cmd_download}" == "${cmd_wget}" ]]; then
	## use wget
	download_args=(-O "-")
	## depend on wgets' builtin url-encoding
	str_postdata="family=${fontfamily}&subset=${subsetspec}"
	if [[ "${formatspec}x" != "x" ]]; then
	    download_args+=(--user-agent="'${useragent[${formatspec}]}'")
	fi
	## needed for making wget understand option arguments stop,
	## and url starts
	download_args+=(--)
	download_args+=("${GOOGLE_FONTAPI_URL}?${str_postdata}")
    else
	## use curl
	download_args=(--get)
	download_args+=(--silent)
	download_args+=(--show-error)
	download_args+=(--fail)
	## depend on curls' builtin url-encoding
	download_args+=(--data-urlencode "family=${fontfamily}")
	download_args+=(--data-urlencode "subset=${subsetspec}")
	if [[ "${formatspec}x" != "x" ]]; then
	    download_args+=(--user-agent "'${useragent[${formatspec}]}'")
	fi
	download_args+=("${GOOGLE_FONTAPI_URL}")
    fi
    ## run downloader as background task, which means we can't trap
    ## it's exit code so trap '400 Bad Request' output
    badrequest_re="400 Bad Request"
    cssattr_font_face="$(LANG=C ${cmd_download} "${download_args[@]}" 2>&1 &)"
    if [[ "${cssattr_font_face}" =~ ${badrequest_re} ]]; then
	processchain="$(printf "%s<-" "${FUNCNAME[@]}")"
	printf "%s: error %s using %s:\n%s\n" \
	       "${processchain}" "${ret}" "${cmd_download}" "${cssattr_font_face}"
	return 1
    else
	## return the complete font-face atrule
	printf "%s" "${cssattr_font_face}"
    fi
}


function validate_arg_formatspec() {
    ## validate the FORMATSPEC specified by the user in $1 against
    ## valid_formatspecs.
    ## returns error if no argument could be validated.
    ## convert comma separated arguments into array
    a_formatspecs=( ${1//,/ } )
    case "${a_formatspecs[@]}x" in 
	allx)
     	    ## argument is 'all'; add all available formats to array
	    a_checked_formatspecs=( ${valid_formatspecs[@]} )
	    ;;
	x|practicalx)
	    ## argument is empty or 'practical'
	    a_checked_formatspecs=( ${practical_formatspecs[@]} )
	    ;;
	*deeper*x)
	    a_checked_formatspecs=( ${slightlydeeper_formatspecs[@]} )
	    ;;
	*progressive*x)
	    a_checked_formatspecs=( ${superprogressive_formatspecs[@]} )
	    ;;
	*)
	    ## user specified FORMATSPECS, try to iterate the array
	    # shellcheck disable=SC2068
	    for formatspec in ${a_formatspecs[@]}; do
		if [[ "${formatspec}x" == "allx" ]]; then
		    a_checked_formatspecs+=( ${valid_formatspecs[@]} )
		    continue
		else
		    # shellcheck disable=SC2076
		    if [[ ${valid_formatspecs[@]} =~ "${formatspec}" ]]; then
			a_checked_formatspecs+=( "${formatspec}" )
		    else
			## invalid FORMATSPEC specified
			err_invalid_arg "arg_formatspecs" "${formatspec}"
		    fi
		fi
	    done
	    ;;
    esac
    if [[ ${#a_checked_formatspecs[@]} -eq 0 ]]; then
	## return error	
	return 1
    else
	## return the array as a space separated list
	printf "%s " "${a_checked_formatspecs[@]}"
    fi
}


function validate_arg_subsetspec() {
    ## validate the SUBSETSPEC specified by the user in $1
    ## against valid_subsetspecs.
    ## returns error if no choice could be validated.
    ## convert comma separated arguments into array
    a_subsetspecs=( ${1//,/ } )
    if [[ "${a_subsetspecs[@]}" =~ all ]]; then
	## when 'all' is chosen skip any other
	a_checked_subsetspecs+=( "all" )
    else
	# shellcheck disable=SC2068,SC2076
	for subsetspec in ${a_subsetspecs[@]}; do
	    if [[ ${valid_subsetspecs[@]} =~ "${subsetspec}" ]]; then   
		a_checked_subsetspecs+=("${subsetspec}")
	    else
		err_invalid_arg "arg_subsetspecs" "${subsetspec}"
	    fi
	done
    fi
    ## return error
    if [[ ${#a_checked_subsetspecs[@]} -eq 0 ]]; then
	return 1
    else
	## return space separated string with valid SUBSETSPECS
	printf "%s " "${a_checked_subsetspecs[@]}"
    fi
}


function process_atrule() {
    ## process the supplied fontface atrule ($1), by extracting all
    ## its attributes, adding the font file name and url for each
    ## FORMATSPEC/SUBSETSPEC to the a_downloads array, and storing the
    ## resulting css in the temporary variable 'temp_atrule'.
    cssattr_font_face="$1"
    cssattr_font_family=""
    cssattr_font_weight=""
    cssattr_font_style=""
    cssattr_src=""	
    cssattr_src_local_nonps=
    cssattr_src_local_ps=
    cssattr_src_url=
    ## initialize for later use
    download_url=
    font_version=""
    a_url_format_attrs=()
    ## setup regular expressions to match css attributes and to
    ## determine their values
    re_font_family="font-family:[[:space:]]*'(.*)';"
    re_font_weight="font-weight:[[:space:]]*(.*);"
    re_font_style="font-style:[[:space:]]*(.*);"
    re_src="src:[[:space:]]*(.*);"
    re_src_local="local\([']?(.*)[']?\)"
    ## matches only the url value 'url(...)' not the optional trailing
    ## 'format(...)'
    re_src_url="url\(([^[:space:]]*)\)"
    re_src_url_version="/(v[0-9]*)/"
    ## process the (newline separated) font-face atrule
    while read -r line; do
	if [[ "${line}" =~ ${re_font_family} ]]; then
	    ## font-family attribute
	    cssattr_font_family="${BASH_REMATCH[1]}"
	elif [[ "${line}" =~ ${re_font_weight} ]]; then
	    ## font-weight attribute
	    cssattr_font_weight="${BASH_REMATCH[1]}"
	elif [[ "${line}" =~ ${re_font_style} ]]; then
	    ## font-style attribute
	    cssattr_font_style="${BASH_REMATCH[1]}"
	elif [[ "${line}" =~ ${re_src} ]]; then
	    ## src attribute
	    cssattr_src="${BASH_REMATCH[1]}"	
	fi
    done<<<"${cssattr_font_face}"
    ## parse the src attribute to extract the 'local' font family
    ## values for both the non-PS and PS family name, and the
    ## 'url(...) format(...)' values for the version of the font
    # shellcheck disable=SC2162
    while IFS=, read local_nonps local_ps url_format; do
	[[ "${local_nonps}" =~ ${re_src_local}  ]] &&
	    cssattr_src_local_nonps="${BASH_REMATCH[1]}"
	[[ "${local_ps}" =~ ${re_src_local} ]] && \
	    cssattr_src_local_ps="${BASH_REMATCH[1]}"
	[[ "${url_format}" =~ ${re_src_url} ]] && \
	    cssattr_src_url="${BASH_REMATCH[1]}"
    done<<<"${cssattr_src}"
    ## remove single quotes if any
    cssattr_src_local_nonps="${cssattr_src_local_nonps//\'/}"
    cssattr_src_local_ps="${cssattr_src_local_ps//\'/}"
    ## create a label for saving and referencing the font file
    if [[ "${cssattr_src_local_nonps}x" == "x" ]]; then
	## local attribute not set; use the font family
	base_localname="${cssattr_font_family}"
    else
	## use the escaped local (non PS) attribute
	base_localname="${cssattr_src_local_nonps}"
    fi
    base_localname="${base_localname// /_}"
    ## try to get the version from the url, otherwise leave empty
    if [[ "${cssattr_src_url}" =~ ${re_src_url_version} ]]; then
	font_version="${BASH_REMATCH[1]}_"
    fi
    ## process each FORMATSPEC/SUBSETSPEC
    # shellcheck disable=SC2068
    for formatspec in ${a_checked_formatspecs[@]}; do
	# shellcheck disable=SC2068
	for subsetspec in ${a_checked_subsetspecs[@]}; do
	    add_eot_src_attr=
	    cssattr_font_face="$(httpget_atrule_google \
	    "${cmd_download}" \
	    "${cssattr_font_family}" \
	    "${cssattr_font_weight}${cssattr_font_style}" \
	    "${subsetspec}" \
	    "${formatspec}")"
	    if [[ $? -ne 0 ]]; then
		processchain="$(printf "%s<-" "${FUNCNAME[@]}")"
		err_exit "ANOMALITY ${processchain}:
${cssattr_font_face}"
	    fi
	    ## determine and set the filename's extension, suffix
	    ## (part after the extension) and other quirk workarounds
	    suffix=
	    label_format="${formatspec}"
	    extension="${formatspec}"
	    case ${formatspec} in
		ttf|truetype)
		    ## replace 'ttf' with 'truetype' if applicable
		    label_format="truetype"
		    extension="ttf"
		    ;;
		svg*)
		    ## agents capable of using svg(z) fonts, gather the
		    ## font family from the suffix after the extension
		    ## and a hash sign with spaces removed, eg.
		    ## 'fontfile.ext#FontFamily'.
		    suffix="#${cssattr_font_family// /}"
		    ;;
		eot*|embedded-opentype)
		    ## 'fontfile.ext?iefix'.
		    label_format="embedded-opentype"
		    suffix="?iefix"
		    add_eot_src_attr=True
		    ;;
		otf*|opentype)
		    ## 'fontfile.ext?iefix'.
		    label_format="opentype"
		    ;;		
	    esac
	    ## construct the filename
	    if [[ "${base_localname}x" == "x" ]]; then
		err_exit "ANOMALITY: empty base_localname; this should not happen."
	    else
		filename="${base_localname}_${font_version}${subsetspec}_${cssattr_font_weight}.${extension}"
	    fi
   	    url_format_template="        url('%s') format('%s'),\n"
	    url_format_template="url('%s') format('%s'),\n"
	    if [[ "${arg_incss_fontsdir}x" != "x" ]]; then
		filename="${arg_incss_fontsdir%/}/${filename}"
	    fi
	    if [[ "${add_eot_src_attr}x" != "x" ]] && [[ "${formatspec}" = "eot" ]]; then
		## prepend the final src variable with the ie9 quirk workaround
		eot_src_attr="src:         url('${filename}');\n"
	    fi
	    # shellcheck disable=SC2059
	    a_url_format_attrs+=("$(printf "${url_format_template}" \
"${filename}${suffix}" "${label_format}")")
	    if [[ "${arg_skipdownload}x" == "x" ]]; then
		## download the web font(s)
		## get the url for this FORMATSPEC/SUBSETSPEC
    		if [[ "${cssattr_font_face}" =~ ${re_src_url} ]]; then
		    download_url="${BASH_REMATCH[1]}"
		else
		    printf 1>&2 "BUG: can't extract url from src attribute=\`%s'\n" \
				"${cssattr_font_face}"
		    ## try the next subsetspec
		    continue
		fi
		## add an array item
		a_downloads[${filename}]="${download_url}"
	    fi
	done 
    done
    ## convert array to multi-lined string
    cssattr_src_urlformats="$(printf "%s\n" "${a_url_format_attrs[@]}")"
    ## replace last comma with semi-colon
    cssattr_src_urlformats="${cssattr_src_urlformats%?};"
    ## generate the atrule and add it to the temp variable
    res=$(generate_css \
	      "${cssattr_font_family}" \
	      "${cssattr_font_style}" \
	      "${cssattr_font_weight}" \
	      "${cssattr_src_local_nonps}" \
	      "${cssattr_src_local_ps}" \
	      "${cssattr_src_urlformats}" \
	      "${eot_src_attr}")
    temp_atrule="$(printf "%s\n" "${res}")"
}


function create_atrules() {
    ## process each item in the fontspecs array, create the proper css
    ## atrule for it and store it in the a_atrules_created array.
    ## setup basic regexp matching
    family_re="(.*):(.*)"
    for family in "${a_arg_fontspecs[@]}"; do
	if [[ "${family}" =~ ${family_re} ]]; then
	    fontname="${BASH_REMATCH[1]}"
	    ## construct array from second match, by replacing commas
	    ## (if any) by spaces to get the requested font styles
	    styles=( ${BASH_REMATCH[2]//,/ } )
	else
	    ## font spec without style; append 'regular'
	    fontname="${family}"
	    styles=( regular )
	fi
	## iterate the array and process each name/style pair
	for fontstyle in "${styles[@]}"; do
	    ## check the validity of the specified name/value pair
            ## (eg. 'Font_Name:weightx,weighty') and get and return it's
	    ## font-face atrule
	    atrule="$(httpget_atrule_google \
"${cmd_download}" \
"${fontname//\'/}" \
"${fontstyle//\'/}" \
"${a_checked_subsetspecs[@]}")"
	    if [[ $? -ne 0 ]]; then
		## add the invalid specification to the array
		a_invalid_specs+=("- '${fontname}:${fontstyle}'" )
	    else
		## process the fontface atrule for the chosen fontname:fontstyle
		## the result is stored in temp_atrule
		temp_atrule=""
		process_atrule "${atrule}"
		if [[ $? -ne 0 ]]; then
		    printf 1>&2 "BUG: error processing atrule:\n%s\nerror was:\n''\n" \
			   "${atrule}" "${res}"
		    return 1
		else
		    ## add the atrule for this fontspec to the array
		    a_atrules_created+=("$(printf "%s\n" "${temp_atrule}")")
		fi
	    fi
	done
    done
    
}

## path to css file
arg_output_cssfile="${arg_output_cssfile:-}"
## font download directory
arg_fonts_dir="${arg_fonts_dir:-}"
## commandline argument -s/--skip-download
arg_skipdownload="${arg_skipdownload:-}"
## commandline argument -x/--skip-local-src-attr
arg_skiplocal="${arg_skiplocal:-}"
## comma separated list of font subsets to be downloaded, defaults to latin
arg_subsetspecs="${arg_subsetspecs:-${DEF_ARG_SUBSETSPECS}}"
## comma separated list of font formats to be downloaded
## defaults to 'practical' (eg 'woff & woff2')
arg_formatspecs="${arg_formatspecs:-${DEF_ARG_FORMATSPECS}}"
arg_overwrite_css="${arg_overwrite_css:-}"
arg_overwrite_fonts="${arg_overwrite_fonts:-}"
arg_includechrome="${arg_includechrome:-}"

## initialize arrays for storing validated selections
## array to hold the commandline font specification(s)
declare -a a_arg_fontspecs
declare -A a_downloads
declare -a a_checked_formatspecs
declare -a a_checked_subsetspecs
declare -a a_atrules_created
declare -a a_warnings
declare -a a_msg_err
declare checked_dir


## valid choices
valid_subsetspecs=(cyrillic cyrillic-ext greek greek-ext latin latin-ext vietnamese all)
valid_formatspecs=(eot otf woff woff2 svg ttf)
## supersets of font formats, taken from:
## https://css-tricks.com/snippets/css/using-font-face/
superprogressive_formatspecs=("woff2")
practical_formatspecs=( ${superprogressive_formatspecs[@]} "woff")    
slightlydeeper_formatspecs=( ${practical_formatspecs[@]} "ttf" )

## use a specific user agent in HTTP requests to Googles font site to get the correct css.
## see: http://www.useragentstring.com/
declare -A useragent="(\
[eot]='Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0)'
[woff]='Mozilla/5.0 (Windows NT 6.1; WOW64; rv:27.0) Gecko/20100101 Firefox/27.0'
[woff2]='Mozilla/5.0 (Windows NT 6.1; WOW64; rv:40.0) Gecko/20100101 Firefox/40.0'
[svg]='Mozilla/4.0 (iPad; CPU OS 4_0_1 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko) Version/4.1 Mobile/9A405 Safari/7534.48.3'
[ttf]='Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.54.16 (KHTML, like Gecko) Version/5.1.4 Safari/534.54.16'
[otf]='Mozilla/5.0 (Windows; U; MSIE 9.0; WIndows NT 9.0; en-US))'\
)"
# shellcheck disable=SC2154
declare -A useragent[svgz]="${useragent[svg]}"

goggle_url_re="['http's]?[s:]?//${GOOGLE_FONTAPI_HOST//./\\\.}/css\?family="
## matching group contains everything upon the next space
goggle_html_link_re="['<link href=\"']?${goggle_url_re}([^[:space:]]*)"
## matching group contains everything upon the next ')'
goggle_js_import_re="['@import url\(']?${goggle_url_re}']?([^\)*)[;]?"

a_invalid_specs=()
a_fonts_exists=()
nr_downloadfonts=0

label_overwrite_all="--overwrite"
label_overwrite_css="--overwrite-css"
label_overwrite_fonts="--overwrite-fonts"
label_includechrome="--include-chrome"
label_skip_localsrc="--skip-local"
if [[ "${0}" =~ /dev/fd.* ]]; then
    ## script loaded from stdin
    label_appname="${APP_NAME}"
else
    label_appname="${0:-APP_NAME}"
fi
cmdline_args_raw="$(printf "%s " "$@" | fmt)"
cmdline_args="$(while read -r line; 
do printf "%s \ \n" "${line}"; 
done< <(printf "%s \n" "${cmdline_args_raw}"))"
## strip last line continuation mark
cmdline_args="${cmdline_args%%\\ }"
css_header="font-face at-rules generated with \
${label_appname} (version ${APP_VERSION}), using command: 
${label_appname} ${cmdline_args}
>>> font-face at-rules start here >>>"
css_footer="<<< generated font-face at-rules end here <<<"

## main program flow
## analyze and store all commandline arguments
analyze_commandline_args "$@" || exit 1
## turn FONTSPECs in arg_fontspecs set by analyze_commandline_args
## into an array.
# shellcheck disable=SC2162
while read fontspec; do
    if [[ "${fontspec}x" != "x" ]]; then
	a_arg_fontspecs+=( "${fontspec}" )
    fi
done<<<"${arg_fontspecs}"
if [[ ${#a_arg_fontspecs[@]} -eq 0 ]]; then
    err_exit "Error: not a single valid FONTSPEC found."
fi
## check user specified FORMATSPEC (applicable for all fontspecs)
a_checked_formatspecs=( $(validate_arg_formatspec "${arg_formatspecs}") )
if [[ $? -ne 0 ]]; then
    err_exit "Error: supplied FORMATSPEC (\`${arg_formatspecs}') is invalid."
fi
## check commandline SUBSETSPEC (applicable for all fontspecs)
a_checked_subsetspecs=( $(validate_arg_subsetspec "${arg_subsetspecs}") )
if [[ $? -ne 0 ]]; then
    err_exit "Error: no valid SUBSETSPEC supplied."
fi
## check which downloader should be used (for checking FONTSPECS and
## downloading fonts).
get_download_cmd

## check the output directory (arg_fonts_dir) if applicable
checked_dir="$(get_fontsdirectory)"
if [[ $? -ne 0 ]]; then
    ## return value contains error message, display it
    printf 1>&2 "%s\n" "${checked_dir}"
    exit 1
fi

## for each verified FONTSPEC create a valid atrule stored in a_atrules
create_atrules
ret=$?
if [[ ${ret} -ne 0 ]]; then
    msg="ANOMALITY:
\`create_atrules' returned error \`${ret}'. This should not happen.
Please check the output of the script above and include that if you
decide to file a bug at ${APP_GITHUBURL}."
    err_exit "${msg}"
fi

## check if warnings were produced by create-atrules
## TODO: turn decision about fatality of FONTSPEC errors into a user
## choice (extra commandline argument)
if [[ ${#a_invalid_specs[@]} -gt 0 ]]; then
    ## invalid (or unparsable) FONTSPEC
    a_msg_err+=("Could not process the following font specifications:")
    a_msg_err+=("$(printf " %s\n" "${a_invalid_specs[@]}")")
fi
## check if valid atrules were created; if not exit with error
if [[ ${#a_atrules_created[@]} -le 0 ]]; then
    str_fontspecs="$(printf "'%s'," "${a_arg_fontspecs[@]}")"
    str_fontspecs=${str_fontspecs%%,}
    if [[ ${#a_arg_fontspecs[@]} -gt 1 ]]; then
	msg="Error: none of your FONTSPECs ${str_fontspecs} \
could be validated. 
Please correct them using ${GOOGLE_FONTS_URL} and try again."
    else
	msg="Error: your FONTSPEC ${str_fontspecs} \
could not be validated. "
	str_fontspecs="${str_fontspecs//\'/}"	
	str_fontspecs="$(rawurlencode "${str_fontspecs}")"
	url="${GOOGLE_FONTS_URL}?query=${str_fontspecs}"
	msg+="Please correct it using \"${url}\" and try again."
    fi
    err_exit "$(echo "${msg}" | fmt -s)"
fi

## check if a css output file is specified, if so if it exists,
## and whether it should be overwritten
if [[ "${arg_output_cssfile}x" == "x" ]]; then
    ## no css output file specified
    arg_output_cssfile=/dev/stdout
else
    ## css output file specified
    if [[ -f "${arg_output_cssfile}" ]] && \
	   [[ "${arg_overwrite_css}x" == "x" ]]; then
	## css output file already exists and should not be overwritten
	msg="- not overwriting existing css file \`${arg_output_cssfile}' \
(tip: use \`${label_overwrite_css}')."
	a_msg_err+=("${msg}" )
	arg_output_cssfile=/dev/stdout
    else
	## css output file does not exist, check the target directory
	cssdir="$(dirname "${arg_output_cssfile}")"
	if [[ -d "${cssdir}" ]]; then
	    ## exisiting target directory
	    if [[ ! -w "${cssdir}" ]]; then
		a_msg_err+=("- directory \`${cssdir}' is not writable.")
		arg_output_cssfile=/dev/stdout
	    fi
	else
	    ## non-exisiting target directory, create it
	    res="$(mkdir -p "${cssdir}" 2>&1)"
	    if [[ $? -ne 0 ]]; then
		a_msg_err+=("- can create directory \`${cssdir}'.")
		arg_output_cssfile=/dev/stdout			
	    fi
	fi 
    fi
fi

## valid FONTSPEC(s) found, start writing css output
## TODO: turn decision about fatality of download errors into a user
## choice (extra commandline argument)
## check if css headers should be included
if [[ "${arg_includechrome}x" == "x" ]]; then
    ## not; check if generated css should be generated
    if [[ "${arg_output_cssfile}x" == "x" ]]; then
	## not; print the header to stdout
	echo "${css_header}" | fmt -s 1>&2
    else
	## clear the output_cssfile
	if [[ -f "${arg_output_cssfile}" ]] && [[ "${arg_output_cssfile}" != "/dev/stdout" ]]; then
	    rm "${arg_output_cssfile}"
	fi
    fi
else
    ## it should; prepend header as commented css and create or
    ## overwrite output_cssfile
    printf "/* %s */\n" "${css_header}" > "${arg_output_cssfile}"
fi
## print real css
for atrule in "${a_atrules_created[@]}"; do 
    printf "%s\n" "${atrule}" >> "${arg_output_cssfile}"
done
## check if css footers should be appended/displayed
if [[ "${arg_includechrome}x" == "x" ]]; then
    if [[ "${arg_output_cssfile}x" == "x" ]]; then     
	echo "${css_footer}" | fmt -s 1>&2
    fi
else
    printf "/* %s */\n" "${css_footer}" >> "${arg_output_cssfile}"
fi
## done printing css
## download the font files if applicable
if [[ "${arg_skipdownload}x" != "x" ]]; then
    a_msg_err+=("skipping downloading of font files as requested.")
else
    printf 1>&2 "Downloading font files " 
    for filename in "${!a_downloads[@]}"; do
	res="$(download_fontfile "${cmd_download}" \
 "${a_downloads[${filename}]}" "${filename}")"
	## consider failed download non-fatal (see TODO above)
	case $? in
	    0) printf 1>&2 "." ;;
	    1) a_fonts_exists+=("- not overwriting \`${res}'") ;; 
	    2) a_msg_err+=("$(printf 1>&2 "%s\n" "${res}")") ;;
	    3) a_msg_err+=("error downloading font file: ${res}") ;;		    
	esac
    done
    if [[ ${#a_fonts_exists[@]} -gt 0 ]]; then 
	nr_downloadfonts=$(( ${#a_downloads[@]} - ${#a_fonts_exists[@]} ))
	printf 1>&2 " ... %s done (%s not overwritten).\n" \
		    "${nr_downloadfonts}" "${#a_fonts_exists[@]}"
    else 
	printf 1>&2 "%s done.\n" "${#a_downloads[@]}"
    fi
    printf 1>&2 "* fonts available in: \`%s'\n" "${checked_dir}"
fi
## display errors/warnings if applicable
if [[ ${#a_msg_err[@]} -gt 0 ]]; then
    printf 1>&2 "\nPlease note the following:\n"
    printf 1>&2 "%s\n" "${a_msg_err[@]}"
    exit 2
else
    if [[ "${arg_output_cssfile}" != "/dev/stdout" ]]; then
	printf 1>&2 "* css file saved in:  \`%s'\n" "${arg_output_cssfile}"
    fi
fi

## all done
